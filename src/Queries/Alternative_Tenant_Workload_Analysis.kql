// ALTERNATIVE TENANT WORKLOAD ANALYSIS - Based on Available MCP Data Sources
// This query builds tenant/subscription workload insights using accessible data sources
// when LogTenantSnapshot is not available in the execution context

// STEP 1: Get Gen4 clusters for analysis
let Gen4WithoutDecomPair =
cluster('azuredcm.kusto.windows.net').database('AzureDCMDb').dcmInventoryGenerationMappingV3
| where ClusterType == 'Compute'
| extend MajorGeneration = split(Generation, '.')[0]
| summarize GenerationList = array_strcat(array_sort_asc(make_set(MajorGeneration)), ',') by ClusterName = ClusterId
| where GenerationList == '4'
| distinct ClusterName
| take 20  // Limit for testing
;

// STEP 2: Subscription-based workload analysis using Internal Usage data
let SubscriptionWorkloadData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._InternalUsage_Cache_CoreUsageBySubscription
| where Cluster in (Gen4WithoutDecomPair)
| where IngestTime > ago(1d)  // Recent data
| summarize arg_max(IngestTime, *) by Cluster, SubscriptionId, VMSeries
| summarize
    UniqueSubscriptions = dcount(SubscriptionId),
    UniqueVMSeries = dcount(VMSeries),
    TotalPhysicalCores = sum(PhysicalCores),
    TotalVirtualCores = sum(VirtualCores),
    VMSeriesList = array_strcat(array_sort_asc(make_set(VMSeries)), ','),
    TopVMSeries = take_any(VMSeries),  // Most common series
    MaxIngestTime = max(IngestTime)
    by Cluster
| extend
    HasDiverseWorkloads = UniqueVMSeries > 5,
    HasHighSubscriptionDensity = UniqueSubscriptions > 100,
    CoreUtilizationFromSubscriptions = TotalPhysicalCores  // This represents actual usage
;

// STEP 3: Allocation pattern analysis for subscription types (when available)
let AllocationPatternData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared').CFRv2_DailyAllocationsSummaryCached
| where Cluster in (Gen4WithoutDecomPair)
| where Time > ago(30d)
| summarize
    TotalAllocations = count(),
    UniqueSubscriptions = dcount(SubscriptionId),
    SpannableRequests = countif(IsSpannedRequest == "true"),
    PinnedRequests = countif(IsPinnedToCluster == true),
    VMSSRequests = countif(IsVMSS == true),
    UltraSSDRequests = countif(IsUltraSSDEnabledClusterRequired == true),
    DedicatedHostRequests = countif(IsDedicatedHostDeployment == true),
    SuccessfulAllocations = countif(ResultType == 0),
    FailedAllocations = countif(ResultType != 0)
    by Cluster
| extend
    HasAllocationActivity = TotalAllocations > 0,
    AllocationFailureRate = iff(TotalAllocations == 0, real(null), todouble(FailedAllocations) / TotalAllocations),
    SpannableRequestRatio = iff(TotalAllocations == 0, real(null), todouble(SpannableRequests) / TotalAllocations * 100.0),
    SpecialtyRequestRatio = iff(TotalAllocations == 0, real(null), todouble(UltraSSDRequests + DedicatedHostRequests) / TotalAllocations * 100.0)
;

// STEP 4: Subscription type classification (using available subscription metadata)
let SubscriptionTypeData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared').CFRv2_SubscriptionInfoCached
| where IngestionTime > ago(7d)
| summarize arg_max(IngestionTime, *) by SubscriptionId
| summarize
    TotalSubscriptions = count(),
    PPSSubscriptions = countif(IsPPS == true),
    TipSubscriptions = countif(IsTip == true),
    PlayFabSubscriptions = countif(IsPlayFab == true)
| extend
    PPSRatio = todouble(PPSSubscriptions) / TotalSubscriptions * 100.0,
    TipRatio = todouble(TipSubscriptions) / TotalSubscriptions * 100.0,
    PlayFabRatio = todouble(PlayFabSubscriptions) / TotalSubscriptions * 100.0
| project TotalSubscriptions, PPSRatio, TipRatio, PlayFabRatio
;

// STEP 5: Internal core consumption details (detailed workload analysis)
let InternalWorkloadData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._CCC_Cache_InternalCoreConsumption
| where Cluster in (Gen4WithoutDecomPair)
| where IngestTime > ago(1d)
| summarize arg_max(IngestTime, *) by Cluster, SubscriptionId, ServiceId
| summarize
    UniqueServices = dcount(ServiceId),
    UniqueSubscriptions = dcount(SubscriptionId),
    PPSWorkloads = countif(IsPPS == true),
    HOBOWorkloads = countif(IsHOBO == true),
    EvictableWorkloads = countif(IsEvictable == true),
    DataPlaneSLAWorkloads = countif(HasDataPlaneSla == true),
    OversubscribableWorkloads = countif(IsOversubscribable == true),
    TotalPhysicalCores = sum(PhysicalCores),
    TotalVirtualCores = sum(VirtualCores),
    UniqueVMSeries = dcount(VMSeries),
    ServiceList = array_strcat(array_sort_asc(make_set(ServiceId)), ','),
    TopServices = make_set(ServiceId, 10)
    by Cluster
| extend
    HasInternalServices = UniqueServices > 0,
    HasPPSWorkloads = PPSWorkloads > 0,
    HasHOBOWorkloads = HOBOWorkloads > 0,
    HasEvictableWorkloads = EvictableWorkloads > 0,
    HasDataPlaneSLA = DataPlaneSLAWorkloads > 0,
    PPSWorkloadRatio = iff(UniqueServices == 0, real(null), todouble(PPSWorkloads) / UniqueServices * 100.0),
    EvictableWorkloadRatio = iff(UniqueServices == 0, real(null), todouble(EvictableWorkloads) / UniqueServices * 100.0)
;

// STEP 6: Combine workload analysis (alternative to LogTenantSnapshot)
let AlternativeTenantWorkloadData = 
SubscriptionWorkloadData
| join kind=fullouter AllocationPatternData on $left.Cluster == $right.Cluster
| join kind=fullouter InternalWorkloadData on $left.Cluster == $right.Cluster
| extend 
    // Coalesce cluster names from different sources
    ClusterName = coalesce(Cluster, Cluster1, Cluster2),
    
    // Create tenant/workload indicators based on available data
    HasPlatformTenant = HasInternalServices,
    HasComplexWorkloads = HasDiverseWorkloads or UniqueServices > 10,
    HasHighValueWorkloads = HasDataPlaneSLA or HasPPSWorkloads,
    HasSpecialtyRequirements = SpecialtyRequestRatio > 10.0,
    
    // Workload complexity scores
    WorkloadComplexityScore = 
        iff(HasDiverseWorkloads, 20, 0) +
        iff(HasHighSubscriptionDensity, 15, 0) +
        iff(HasPPSWorkloads, 10, 0) +
        iff(HasDataPlaneSLA, 10, 0) +
        iff(HasSpecialtyRequirements, 15, 0) +
        iff(UniqueServices > 5, 10, 0),
    
    // Risk indicators
    EvictionRisk = iff(EvictableWorkloadRatio > 50.0, "High", iff(EvictableWorkloadRatio > 20.0, "Medium", "Low")),
    AllocationRisk = iff(AllocationFailureRate > 0.1, "High", iff(AllocationFailureRate > 0.05, "Medium", "Low"))
    
| project 
    Tenant = ClusterName,
    HasPlatformTenant,
    HasComplexWorkloads,
    HasHighValueWorkloads,
    HasSpecialtyRequirements,
    UniqueSubscriptions,
    UniqueServices,
    UniqueVMSeries,
    WorkloadComplexityScore,
    TotalPhysicalCores,
    TotalVirtualCores,
    PPSWorkloadRatio,
    EvictableWorkloadRatio,
    AllocationFailureRate,
    EvictionRisk,
    AllocationRisk,
    TopServices,
    VMSeriesList
| where isnotempty(Tenant)
;

// Return the alternative tenant workload analysis
AlternativeTenantWorkloadData
| sort by WorkloadComplexityScore desc
