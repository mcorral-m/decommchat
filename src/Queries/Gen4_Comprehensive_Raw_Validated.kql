// COMPREHENSIVE RAW DATA EXTRACTION - Validated and Properly Contextualized
// Execute from OneCapacity cluster context for better cross-cluster access
// Data availability notes: Some sources have limited recent data for specific clusters

// STEP 1: Gen4 clusters (tested and working)
let Gen4WithoutDecomPair =
cluster('azuredcm.kusto.windows.net').database('AzureDCMDb').dcmInventoryGenerationMappingV3
| where ClusterType == 'Compute'
| extend MajorGeneration = split(Generation, '.')[0]
| summarize GenerationList = array_strcat(array_sort_asc(make_set(MajorGeneration)), ',') by ClusterName = ClusterId
| where GenerationList == '4'
| distinct ClusterName
| take 50  // Limit to 50 clusters for better performance during testing
;

// STEP 2: Utilization & infra (tested and working)
let ClusterUtilizationData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared').EfficiencyTracker_Get_LatestDecommInsights
| where Cluster in (Gen4WithoutDecomPair)
| summarize
    TotalCore = todouble(sum(TotalPhysicalCores)),
    UsedCore = todouble(sum(UsedCores)),
    UsedSQL = todouble(sum(UsedCores_SQL)),
    UsedNonSQL = todouble(sum(UsedCores_NonSQL)),
    UsedNonSQL_Spannable = todouble(sum(UsedCores_NonSQL_Spannable)),
    UsedNonSQL_NonSpannable = todouble(sum(UsedCores_NonSQL_NonSpannable)),

    VMCount = sum(VMCount),
    VMCount_SQL = sum(VMCount_SQL),
    VMCount_NonSQL = sum(VMCount_NonSQL),
    VMCount_NonSQL_Spannable = sum(VMCount_NonSQL_Spannable),
    VMCount_NonSQL_NonSpannable = sum(VMCount_NonSQL_NonSpannable),
    MaxSupportedVMs = sum(MaxSupportedVMs),

    Nodes = sum(NodeCount),
    RackCount = sum(RackCount),
    OutOfServices = sum(NodeCount_OOS),
    DNG_Nodes = sum(NodeCount_DNG),
    TIP_Nodes = sum(NodeCount_TIP),
    StrandedCores_DNG = todouble(sum(StrandedPhysicalCores_DNG)),
    StrandedCores_TIP = todouble(sum(StrandedPhysicalCores_TIP)),

    NodeCount_IOwnMachine = sum(NodeCount_IOwnMachine),
    NodeCount_32VMs = sum(NodeCount_32VMs),
    StrandedCores_32VMs = todouble(sum(StrandedPhysicalCores_32VMs)),

    PhysicalCoresPerNode = any(PhysicalCoresPerNode),
    MPCountInCluster = any(MPCountInCluster),
    RackCountInCluster = any(RackCountInCluster),
    IsLive = any(IsLive),
    ClusterType = any(ClusterType),
    IsTargetMP = any(IsTargetMP),
    TenantWithMaxFD = any(TenantNameWithMaxFDCountInCluster),

    Generation = any(Generation),
    Manufacturer = any(Manufacturer),
    MemCategory = any(MemCategory),
    IsSpecialtySKU = any(IsSpecialtySKU),
    TransitionSKUCategory = any(TransitionSKUCategory)
    by Cluster
| extend
    CoreUtilization = iff(isnull(TotalCore) or TotalCore == 0, real(null), UsedCore / TotalCore * 100.0),
    VMDensity = iff(isnull(MaxSupportedVMs) or MaxSupportedVMs == 0, real(null), todouble(VMCount) / MaxSupportedVMs * 100.0),
    OutOfServicesPercentage = iff(isnull(Nodes) or Nodes == 0, real(null), todouble(OutOfServices) / Nodes * 100.0),
    SQL_Ratio = iff(isnull(UsedCore) or UsedCore == 0, real(null), UsedSQL / UsedCore * 100.0),
    NonSpannable_Ratio = iff(isnull(UsedNonSQL) or UsedNonSQL == 0, real(null), UsedNonSQL_NonSpannable / UsedNonSQL * 100.0),
    SpannableUtilizationRatio = iff(isnull(UsedNonSQL_Spannable + UsedNonSQL_NonSpannable) or (UsedNonSQL_Spannable + UsedNonSQL_NonSpannable) == 0,
                                    real(null), UsedNonSQL_Spannable / (UsedNonSQL_Spannable + UsedNonSQL_NonSpannable) * 100.0),
    HealthyNodeRatio = iff(isnull(Nodes) or Nodes == 0, real(null), todouble(Nodes - OutOfServices - DNG_Nodes) / Nodes * 100.0),
    EffectiveCoreUtilization = iff(isnull(TotalCore) or TotalCore == 0, real(null), (UsedCore - StrandedCores_DNG - StrandedCores_TIP) / TotalCore * 100.0)
;

// STEP 3: Properties & ages (fixed negative age calculation)
let ClusterPropertiesData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._CCC_Cache_ClusterProperties
| where Cluster in (Gen4WithoutDecomPair)
| where isnotempty(ClusterLIVEDate)
| summarize arg_max(PreciseTimeStamp, *) by Cluster
| extend
    // Fix the age calculation - use absolute value if negative and handle date format issues
    ClusterAgeDays_Raw = datetime_diff('day', now(), ClusterLIVEDate),
    ClusterAgeDays = iff(datetime_diff('day', now(), ClusterLIVEDate) < 0, 
                         datetime_diff('day', ClusterLIVEDate, now()), 
                         datetime_diff('day', now(), ClusterLIVEDate)),
    DecommissionTimeRemaining = iff(isnotempty(ClusterDecommisionDate), 
                                   datetime_diff('day', ClusterDecommisionDate, now()), 
                                   int(null))
| extend
    ClusterAgeYears = todouble(ClusterAgeDays) / 365.25,
    DecommissionYearsRemaining = iff(isnull(DecommissionTimeRemaining), 
                                   real(null), 
                                   todouble(DecommissionTimeRemaining) / 365.25)
| project Cluster, Region, DC, AvailabilityZone, PhysicalAZ,
    ClusterAgeDays, ClusterAgeYears, DecommissionTimeRemaining, DecommissionYearsRemaining,
    Generation, Manufacturer, MemCategory, CloudType, RegionType, Intent, IntentIsSellable,
    SKUName, Servers, NumRacks, IsUltraSSDEnabled, IsSpecialtySKU
;

// STEP 4: Tenant/platform workload analysis
// PRIMARY: LogTenantSnapshot (works in user environment)
// ALTERNATIVE: Subscription-based analysis (works in MCP environment)

// Try LogTenantSnapshot first (user environment)
let TenantWorkloadData_Primary =
LogTenantSnapshot
| where PreciseTimeStamp > ago(2h)
| where Tenant in (Gen4WithoutDecomPair)
| extend NonGuidTenant = isempty(toguid(tenantName))
| summarize arg_max(PreciseTimeStamp, *) by Tenant, tenantName
| extend TenantInfo = strcat(tenantName, ':#', numRoleInstances, ':U-', maxUpdateDomain)
| extend HasUDGreaterThan10_flag = iff(toint(maxUpdateDomain) > 10, 1, 0),
        HasInstancesGreaterThan10_flag = iff(toint(numRoleInstances) > 10, 1, 0)
| summarize
    GuidTenant = countif(NonGuidTenant == false),
    MaxUpdateDomain = maxif(maxUpdateDomain, NonGuidTenant == true),
    TenantList = array_strcat(array_sort_asc(make_set_if(TenantInfo, NonGuidTenant == true)), ','),
    HasUDGreaterThan10 = iff(sum(HasUDGreaterThan10_flag) > 0, true, false),
    HasInstancesGreaterThan10 = iff(sum(HasInstancesGreaterThan10_flag) > 0, true, false),
    TotalInstances = sum(toint(numRoleInstances)),
    TenantCount = count()
    by Tenant
| extend
    HasSLB = iff(TenantList contains 'slb', true, false),
    HasWARP = iff(TenantList contains 'warp', true, false),
    HasPlatformTenant = isnotempty(TenantList),
    DataSource = "LogTenantSnapshot"
| project Tenant, HasPlatformTenant, HasWARP, HasSLB, HasUDGreaterThan10, HasInstancesGreaterThan10, TotalInstances, TenantCount, DataSource
;

// ALTERNATIVE: Subscription-based analysis (MCP compatible)
let TenantWorkloadData_Alternative =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._InternalUsage_Cache_CoreUsageBySubscription
| where Cluster in (Gen4WithoutDecomPair)
| where IngestTime > ago(1d)  // Recent data only
| summarize arg_max(IngestTime, *) by Cluster, SubscriptionId, VMSeries
| summarize
    UniqueSubscriptions = dcount(SubscriptionId),
    UniqueVMSeries = dcount(VMSeries),
    TotalPhysicalCoresFromSubscriptions = sum(PhysicalCores),
    VMSeriesList = array_strcat(array_sort_asc(make_set(VMSeries)), ',')
    by Cluster
| extend
    // Platform tenant indicators based on subscription patterns
    HasPlatformTenant = UniqueSubscriptions > 0,
    HasDiverseWorkloads = UniqueVMSeries > 5,
    HasHighSubscriptionDensity = UniqueSubscriptions > 100,
    
    // Workload type indicators based on VM series patterns
    HasWARP = VMSeriesList contains "A",
    HasSLB = VMSeriesList contains "F", 
    
    // Simulate traditional fields using calculated values
    TotalInstances = toint(TotalPhysicalCoresFromSubscriptions / 2),
    TenantCount = UniqueSubscriptions,
    DataSource = "SubscriptionAnalysis"
| extend
    // Second extend for fields that depend on previous calculations
    HasUDGreaterThan10 = HasHighSubscriptionDensity,
    HasInstancesGreaterThan10 = TotalPhysicalCoresFromSubscriptions > 1000
| project 
    Tenant = Cluster, 
    HasPlatformTenant, 
    HasWARP, 
    HasSLB, 
    HasUDGreaterThan10, 
    HasInstancesGreaterThan10, 
    TotalInstances, 
    TenantCount,
    DataSource
;

// Use primary data if available, otherwise use alternative
let TenantWorkloadData =
union TenantWorkloadData_Primary, TenantWorkloadData_Alternative
| summarize arg_max(DataSource, *) by Tenant  // Prefer LogTenantSnapshot if both exist
| project Tenant, HasPlatformTenant, HasWARP, HasSLB, HasUDGreaterThan10, HasInstancesGreaterThan10, TotalInstances, TenantCount
;

// STEP 5: ACU efficiency (NOTE: Historical data only - last data from 2023-06-09)
// Will return empty results for most clusters due to outdated data
let ACUEfficiencyData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared').EfficiencyTracker_API_Utilization_v0
| where Cluster in (Gen4WithoutDecomPair)
| where ObjectTime > ago(365d)  // Broader range but still likely empty
| summarize arg_max(ObjectTime, *) by Cluster
| project Cluster,
    TotalPhysicalACUs = TotalPhysicalACUsInclFabric,
    BufferAndOverheadACUs,
    ClusterBonusACUs,
    SellableACUs = ActualSellableACUsInclBonus,
    UsedACUsHiPri,
    UsedACUsLowPri,
    SellableAgainstPurchasedPercent,
    UsedHiPriAgainstPurchasedPercent,
    UsedHiPriAgainstSellablePercent
;

// STEP 6: Allocation failure (Broader time range for better coverage)
// Note: Only clusters with actual allocation activity will have data
let AllocationFailureData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared').CFRv2_DailyAllocationsSummaryCached
| where Cluster in (Gen4WithoutDecomPair)
| where Time > ago(90d)  // Broader time range for better data coverage
| extend IsSuccess = iff(ResultType == 0, 1, 0), IsFailed = iff(ResultType != 0, 1, 0)
| summarize
    SuccessfulAllocations_7d = sumif(IsSuccess, Time > ago(7d)),
    FailedAllocations_7d = sumif(IsFailed, Time > ago(7d)),
    TotalAllocations_7d = countif(Time > ago(7d)),
    SuccessfulAllocations_30d = sumif(IsSuccess, Time > ago(30d)),
    FailedAllocations_30d = sumif(IsFailed, Time > ago(30d)),
    TotalAllocations_30d = countif(Time > ago(30d))
    by Cluster
| extend
    AllocationFailureRate_7d = iff(TotalAllocations_7d == 0, real(null), todouble(FailedAllocations_7d) / TotalAllocations_7d),
    AllocationFailureRate_30d = iff(TotalAllocations_30d == 0, real(null), todouble(FailedAllocations_30d) / TotalAllocations_30d)
| project Cluster, AllocationFailureRate_7d, AllocationFailureRate_30d,
    SuccessfulAllocations_7d, FailedAllocations_7d, SuccessfulAllocations_30d, FailedAllocations_30d
;

// STEP 7: TiP nodes (Has recent data but limited cluster coverage)
let TiPNodeData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._CCC_Cache_TipNodeConsumption
| where Cluster in (Gen4WithoutDecomPair)
| where IngestTime > ago(1d)
| summarize arg_max(IngestTime, *) by Cluster, NodeId
| summarize
    TiPEmptyNodes = countif(EmptyNode == true),
    TiPActiveNodes = countif(EmptyNode == false),
    TiPTotalNodes = count(),
    TiPEmptyPhysicalCores = todouble(sumif(NodePhysicalCores, EmptyNode == true))
    by Cluster
| extend TiPEmptyNodeRatio = iff(TiPTotalNodes == 0, real(null), todouble(TiPEmptyNodes) / TiPTotalNodes * 100.0)
| project Cluster, TiPEmptyNodes, TiPActiveNodes, TiPEmptyNodeRatio, TiPEmptyPhysicalCores
;

// STEP 8: Regional context (tested and working)
let AllClusters =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._CCC_Cache_ClusterProperties
| where isnotempty(Region) and ClusterType == 'Compute'
| summarize arg_max(PreciseTimeStamp, *) by Cluster
| project Cluster, Region, Generation
;

let RegionalContextData =
AllClusters
| extend MajorGeneration = split(Generation, '.')[0]
| summarize ClustersByGeneration = dcount(Cluster) by Region, MajorGeneration
| summarize TotalClusters = sum(ClustersByGeneration), Gen4Count = sumif(ClustersByGeneration, MajorGeneration == '4') by Region
| join kind=leftouter (
    AllClusters
    | extend MajorGeneration = split(Generation, '.')[0]
    | summarize ClustersByGeneration = dcount(Cluster) by Region, MajorGeneration
    | summarize arg_max(ClustersByGeneration, MajorGeneration) by Region
) on Region
| extend Gen4Ratio = iff(TotalClusters == 0, real(null), todouble(Gen4Count) / TotalClusters * 100.0)
| project Region, TotalClusters, Gen4Count, Gen4Ratio, DominantGeneration = tostring(MajorGeneration)
;

// STEP 9: Hot regions (tested and working)
let HotRegionsData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._Cache_Fraud_RegionPrioritization
| where Reason == 'Hot Region'
| where TimeStamp >= ago(2h)
| summarize
    RegionHotnessPriority = min(Priority),
    IsHotRegion = bool(true),
    HotRegionVMSeriesList = make_set(VMSeries),
    LatestHotTimestamp = max(TimeStamp)
    by Region
| extend HotRegionVMSeries = array_strcat(HotRegionVMSeriesList, ',')
| project Region, RegionHotnessPriority, IsHotRegion, HotRegionVMSeries, LatestHotTimestamp
;

// STEP 10: Regional health (tested and working with current data)
let RegionalHealthData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._CCC_Cache_RegionHealthLevel_Prediction
| where PreciseTimeStamp >= ago(1d)
| summarize arg_max(PreciseTimeStamp, *) by Region
| project Region, RegionHealthScore = ProjectedRegionHealthScore, RegionHealthLevel = ProjectedRegionHealthLevel, RegionHealthProjectedTime
;

// STEP 11: Combine all data sources (graceful handling of missing data with left joins)
ClusterUtilizationData
| join kind=inner TenantWorkloadData on $left.Cluster == $right.Tenant
| join kind=leftouter ClusterPropertiesData on $left.Cluster == $right.Cluster
| join kind=leftouter ACUEfficiencyData on $left.Cluster == $right.Cluster
| join kind=leftouter AllocationFailureData on $left.Cluster == $right.Cluster
| join kind=leftouter TiPNodeData on $left.Cluster == $right.Cluster
| join kind=leftouter RegionalContextData on $left.Region == $right.Region
| join kind=leftouter HotRegionsData on $left.Region == $right.Region
| join kind=leftouter RegionalHealthData on $left.Region == $right.Region
| extend HasSQL = iff(isnull(UsedSQL), bool(null), UsedSQL > 0)
| project
    ClusterId = Cluster,
    Region, AvailabilityZone, DataCenter = DC, PhysicalAZ,
    ClusterAgeYears, ClusterAgeDays, DecommissionYearsRemaining, Intent, IntentIsSellable,
    Generation, Manufacturer, MemCategory, SKUName, Servers, NumRacks,
    IsUltraSSDEnabled, IsSpecialtySKU, CloudType, RegionType, TransitionSKUCategory,

    PhysicalCoresPerNode, MPCountInCluster, RackCountInCluster, IsLive, ClusterType,

    TotalPhysicalCores = TotalCore, UsedCores = UsedCore, UsedCores_SQL = UsedSQL,
    UsedCores_NonSQL = UsedNonSQL, UsedCores_NonSQL_Spannable = UsedNonSQL_Spannable,
    UsedCores_NonSQL_NonSpannable = UsedNonSQL_NonSpannable, CoreUtilization,

    VMCount, VMCount_SQL, VMCount_NonSQL, VMCount_NonSQL_Spannable, VMCount_NonSQL_NonSpannable,
    MaxSupportedVMs, VMDensity,

    TotalNodes = Nodes, OutOfServiceNodes = OutOfServices, DNG_Nodes, TIP_Nodes,
    StrandedCores_DNG, StrandedCores_TIP, OutOfServicesPercentage,
    NodeCount_IOwnMachine, NodeCount_32VMs, StrandedCores_32VMs, IsTargetMP,

    HasPlatformTenant, HasWARP, HasSLB, HasSQL, HasUDGreaterThan10, HasInstancesGreaterThan10,
    TotalInstances, TenantCount, TenantWithMaxFD,

    TotalPhysicalACUs, BufferAndOverheadACUs, ClusterBonusACUs, SellableACUs,
    UsedACUsHiPri, UsedACUsLowPri, SellableAgainstPurchasedPercent,
    UsedHiPriAgainstPurchasedPercent, UsedHiPriAgainstSellablePercent,

    AllocationFailureRate_7d, AllocationFailureRate_30d,
    SuccessfulAllocations_7d, FailedAllocations_7d, SuccessfulAllocations_30d, FailedAllocations_30d,

    TiPEmptyNodesCount = TiPEmptyNodes, TiPActiveNodesCount = TiPActiveNodes,
    TiPEmptyNodeRatio, TiPPhysicalCoresEmpty = TiPEmptyPhysicalCores,

    RegionTotalClusters = todouble(TotalClusters), RegionGen4ClustersCount = todouble(Gen4Count),
    RegionGen4Ratio, RegionDominantGeneration = DominantGeneration,

    IsHotRegion, RegionHotnessPriority, HotRegionVMSeries,
    RegionHealthScore, RegionHealthLevel

| sort by ClusterId asc
