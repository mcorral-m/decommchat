#nullable enable
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using MyM365AgentDecommision.Bot.Interfaces;  // IClusterDataProvider
using MyM365AgentDecommision.Bot.Models;      // ClusterRow
using MyM365AgentDecommision.Bot.Services;    // ScoringService

namespace MyM365AgentDecommision.Bot.Plugins
{
    /// <summary>
    /// Plugin providing access to cluster filtering, sorting, and criteria-based selection.
    /// Supports single-criteria filtering and multi-criteria plans (Union/Intersect).
    /// Also supports natural-language weight parsing for "filter → score" workflows.
    /// </summary>
    public sealed class ClusterFilteringPlugin
    {
        private readonly IClusterDataProvider _data;
        private readonly ILogger<ClusterFilteringPlugin>? _log;
        private readonly ScoringService _scoringService;

        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)
        {
            PropertyNameCaseInsensitive = true,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
            WriteIndented = false
        };

        public ClusterFilteringPlugin(
            IClusterDataProvider data,
            ScoringService scoringService,
            ILogger<ClusterFilteringPlugin>? log = null)
        {
            _data = data;
            _scoringService = scoringService;
            _log = log;
        }

        // ---------------------- Typed DTOs (no anonymous objects) -----------------

        public sealed record ErrorDto(string Error);
        public sealed record FieldInfo(string Name, string Kind);

        public sealed record FilterResponse(
            int Total,        // total rows in dataset
            int Returned,     // rows after filter
            IEnumerable<ClusterRow> Items
        );

        public sealed record PlanResponse(
            string Mode,      // "Union" | "Intersect"
            int Total,
            int Returned,
            IEnumerable<ClusterRow> Items
        );

        // ------------------------------------------------------------------------
        // Discovery helpers (introspection/templates)
        // ------------------------------------------------------------------------
        [KernelFunction, Description("List filterable fields and types supported by the engine.")]
        public string ListFilterableFields()
        {
            var fields = ClusterFilterEngine.ListSupportedFields()
                .Select(t => new FieldInfo(t.Field, t.Kind))
                .ToList();

            return JsonSerializer.Serialize(fields, JsonOpts);
        }

        [KernelFunction, Description("Return an example Criteria JSON template.")]
        public string CriteriaTemplate()
        {
            var crit = new ClusterFilterEngine.Criteria
            {
                SortBy = "ClusterAgeYears",
                SortDescending = true,
                Take = 10
            };
            return JsonSerializer.Serialize(crit, JsonOpts);
        }

        /// <summary>
        /// Kernel function to parse weight instructions (JSON, k=v pairs, or natural language)
        /// and return raw + normalized canonical weights (same contract as ScoringPlugin).
        /// </summary>
        [KernelFunction, Description("Parse weight instructions and return {weightsRaw, weightsNormalized, primaryFactor}.")]
        public Task<string> ExtractWeightsAsync(
            [Description("User text, JSON, or k=v pairs describing weights")]
            string text,
            CancellationToken ct = default)
        {
            var raw = ParseWeightsFlexible(text) ?? ScoringService.DefaultWeights();
            var normalized = ScoringService.Rebalance(new ScoringService.WeightConfig(raw));
            var primary = normalized.OrderByDescending(kv => kv.Value).First().Key;

            var payload = new
            {
                weightsRaw = raw,
                weightsNormalized = normalized,
                primaryFactor = primary
            };

            return Task.FromResult(JsonSerializer.Serialize(payload, JsonOpts));
        }

        /// <summary>
        /// Gets information about scoring factors that can be customized with weights.
        /// </summary>
        [KernelFunction, Description("List all available scoring factors that can be customized with weights.")]
        public string GetScorableFactors()
        {
            var catalog = _scoringService.GetFeatureCatalog();
            var factors = catalog.Select(f => new
            {
                Name = f.Name,
                Kind = f.Kind,
                Unit = f.Unit,
                HigherIsBetter = f.HigherIsBetter,
                Description = GetFactorDescription(f.Name)
            }).ToList();

            return JsonSerializer.Serialize(factors, JsonOpts);
        }

        /// <summary>
        /// Tutorial for customizing weights.
        /// </summary>
        [KernelFunction, Description("Get a tutorial on how to customize scoring weights for decommissioning.")]
        public string GetWeightCustomizationTutorial()
        {
            var tutorial = @"# Customizing Decommission Scoring Weights

- You may specify weights as JSON, as `k=v` pairs, or in natural language.
- We normalize weights to sum to 1.0 automatically.
- Some features are inverted (e.g., lower utilization → higher score).

Examples:
- JSON: { ""age"": 0.9, ""utilization"": 0.1 }
- Pairs: age=0.9, utilization=0.1
- Natural language: ""higher weight (0.9) on age and lower weight (0.1) on utilization""

Tip: For strict age-only ranking, set ClusterAgeYears=1.0.";
            return tutorial;
        }

        /// <summary>
        /// Creates a custom weight configuration from comma-separated factor=weight pairs (friendly keys allowed).
        /// </summary>
        [KernelFunction, Description("Create a custom weight configuration from comma-separated factor=weight pairs (friendly keys allowed).")]
        public string CreateCustomWeights(string weightPairs)
        {
            try
            {
                var dict = new ScoringService.WeightConfig();
                foreach (var part in weightPairs.Split(',', StringSplitOptions.RemoveEmptyEntries))
                {
                    var kv = part.Split('=', 2, StringSplitOptions.TrimEntries);
                    if (kv.Length != 2) continue;
                    if (double.TryParse(kv[1], NumberStyles.Float, CultureInfo.InvariantCulture, out var v))
                    {
                        dict[CanonFeature(kv[0])] = v;
                    }
                }

                var norm = ScoringService.Rebalance(dict);
                return JsonSerializer.Serialize(norm, JsonOpts);
            }
            catch (Exception ex)
            {
                return JsonSerializer.Serialize(new ErrorDto($"Failed to create weights: {ex.Message}"), JsonOpts);
            }
        }

        /// <summary>
        /// Retrieves the default scoring weights used by the system.
        /// </summary>
        [KernelFunction, Description("Get the default weights used by the scoring system.")]
        public string GetDefaultWeights()
        {
            try
            {
                var defaultWeights = ScoringService.DefaultWeights();

                var result = defaultWeights.Select(kv => new
                {
                    Factor = kv.Key,
                    Weight = kv.Value,
                    Description = GetFactorDescription(kv.Key)
                })
                .OrderByDescending(x => x.Weight)
                .ToList();

                return JsonSerializer.Serialize(result, JsonOpts);
            }
            catch (Exception ex)
            {
                return JsonSerializer.Serialize(new ErrorDto($"Failed to get default weights: {ex.Message}"), JsonOpts);
            }
        }

        // ------------------------------------------------------------------------
        // Single-criteria filtering (JSON in → filtered rows out)
        // ------------------------------------------------------------------------
        [KernelFunction, Description("Filter clusters by one Criteria JSON. Returns {total, returned, items}.")]
        public async Task<string> FilterByCriteriaJsonAsync(
            [Description("JSON encoding of ClusterFilterEngine.Criteria")] string criteriaJson,
            CancellationToken ct = default)
        {
            try
            {
                var rows = await _data.GetClusterRowDataAsync(ct);

                ClusterFilterEngine.Criteria criteria;
                try
                {
                    criteria = JsonSerializer.Deserialize<ClusterFilterEngine.Criteria>(criteriaJson, JsonOpts) ?? new();
                }
                catch (Exception ex)
                {
                    _log?.LogWarning(ex, "Invalid criteria JSON");
                    return JsonSerializer.Serialize(new ErrorDto($"Invalid criteria JSON: {ex.Message}"), JsonOpts);
                }

                var result = ClusterFilterEngine.Apply(rows, criteria);
                var payload = new FilterResponse(
                    Total: rows.Count,
                    Returned: result.Count,
                    Items: result
                );
                return JsonSerializer.Serialize(payload, JsonOpts);
            }
            catch (OperationCanceledException)
            {
                return JsonSerializer.Serialize(new ErrorDto("Operation cancelled."), JsonOpts);
            }
            catch (Exception ex)
            {
                _log?.LogError(ex, "FilterByCriteriaJsonAsync failed");
                return JsonSerializer.Serialize(new ErrorDto($"Unhandled error: {ex.Message}"), JsonOpts);
            }
        }

        // ------------------------------------------------------------------------
        // Multi-criteria plan (Union/Intersect across multiple Criteria blocks)
        // ------------------------------------------------------------------------
        [KernelFunction, Description("Run a multi-query plan (Union/Intersect of multiple Criteria). Returns {mode, total, returned, items}.")]
        public async Task<string> FilterByMultiPlanJsonAsync(
            [Description("JSON encoding of ClusterFilterEngine.MultiQueryPlan")] string planJson,
            CancellationToken ct = default)
        {
            try
            {
                var rows = await _data.GetClusterRowDataAsync(ct);

                ClusterFilterEngine.MultiQueryPlan? plan;
                try
                {
                    plan = JsonSerializer.Deserialize<ClusterFilterEngine.MultiQueryPlan>(planJson, JsonOpts);
                }
                catch (Exception ex)
                {
                    _log?.LogWarning(ex, "Invalid plan JSON");
                    return JsonSerializer.Serialize(new ErrorDto($"Invalid plan JSON: {ex.Message}"), JsonOpts);
                }

                if (plan is null || plan.Items is null || plan.Items.Count == 0)
                    return JsonSerializer.Serialize(new ErrorDto("Plan.Items is empty."), JsonOpts);

                var result = ClusterFilterEngine.ApplyMany(rows, plan);
                var payload = new PlanResponse(
                    Mode: plan.Mode,
                    Total: rows.Count,
                    Returned: result.Count,
                    Items: result
                );
                return JsonSerializer.Serialize(payload, JsonOpts);
            }
            catch (OperationCanceledException)
            {
                return JsonSerializer.Serialize(new ErrorDto("Operation cancelled."), JsonOpts);
            }
            catch (Exception ex)
            {
                _log?.LogError(ex, "FilterByMultiPlanJsonAsync failed");
                return JsonSerializer.Serialize(new ErrorDto($"Unhandled error: {ex.Message}"), JsonOpts);
            }
        }

        // ------------------------------------------------------------------------
        // Filter → Score in one call (smart weights + deterministic ranking)
        // ------------------------------------------------------------------------
        /// <summary>
        /// Filters and scores clusters in a single operation.
        /// Accepts friendly/JSON/natural-language weights. Disables winsorization for single-factor runs.
        /// Adds deterministic tie-breaker by the primary factor's raw value.
        /// </summary>
        [KernelFunction, Description("Filter and score clusters with optional custom weights (friendly keys allowed), returning top N candidates.")]
        public async Task<string> FilterAndScoreAsync(
            [Description("Optional JSON criteria for filtering clusters")] string? filterCriteria = null,
            [Description("Optional weight configuration (JSON, 'k=v' pairs, or natural language)")] string? weightConfig = null,
            [Description("Number of top-scored clusters to return")] int topN = 10,
            CancellationToken ct = default)
        {
            try
            {
                // Step 1: Load data
                var rows = await _data.GetClusterRowDataAsync(ct);

                // Step 2: Apply filter (if provided)
                IReadOnlyList<ClusterRow> filteredRows = rows;
                if (!string.IsNullOrWhiteSpace(filterCriteria))
                {
                    try
                    {
                        var criteria = JsonSerializer.Deserialize<ClusterFilterEngine.Criteria>(filterCriteria, JsonOpts) ?? new();
                        filteredRows = ClusterFilterEngine.Apply(rows, criteria);
                    }
                    catch (Exception ex)
                    {
                        _log?.LogWarning(ex, "Invalid filter criteria JSON");
                        return JsonSerializer.Serialize(new ErrorDto($"Invalid filter criteria JSON: {ex.Message}"), JsonOpts);
                    }
                }

                // Step 3: Parse weights (friendly keys + k=v pairs + natural language)
                var weights = ParseWeightsFlexible(weightConfig);

                // Step 4: Scoring options - disable winsorization for single-factor runs
                var options = new ScoringService.ScoringOptions();
                if (weights is not null)
                {
                    var active = weights.Where(kv => kv.Value > 0).Select(kv => kv.Key).ToList();
                    if (active.Count == 1)
                    {
                        options = new ScoringService.ScoringOptions { Winsorize = false };
                    }
                }

                // Step 5: Score everything once, then filter the results to our filtered set
                var scoreResult = await _scoringService.ScoreAllAsync(weights, options, ct);

                var filteredIds = new HashSet<string>(
                    filteredRows.Select(r => r.Cluster ?? r.ClusterId ?? string.Empty),
                    StringComparer.OrdinalIgnoreCase);

                // Determine primary factor for deterministic tie-break
                var weightsRaw = weights ?? ScoringService.DefaultWeights();
                var weightsNormalized = ScoringService.Rebalance(new ScoringService.WeightConfig(weightsRaw));
                var primary = weightsNormalized.OrderByDescending(kv => kv.Value).First().Key;

                double TieKey(ScoringService.ScoreRowBreakdown r)
                {
                    var f = r.Factors.FirstOrDefault(x => string.Equals(x.Property, primary, StringComparison.OrdinalIgnoreCase));
                    if (f is null || f.Raw is null) return double.NaN;
                    return f.Inverted ? -f.Raw.Value : f.Raw.Value;
                }

                var ranked = scoreResult.Rankings
                    .Where(r => filteredIds.Contains(r.Cluster))
                    .OrderByDescending(r => r.Score)
                    .ThenByDescending(r => TieKey(r))
                    .Take(Math.Min(topN, filteredRows.Count))
                    .ToList();

                // Step 6: Build a rich response with details
                var rowLookup = rows.ToDictionary(r => r.Cluster ?? r.ClusterId ?? string.Empty, StringComparer.OrdinalIgnoreCase);

                var result = new
                {
                    Total = rows.Count,
                    Filtered = filteredRows.Count,
                    Returned = ranked.Count,
                    PrimaryFactor = primary,
                    CustomWeightsApplied = weights is not null,
                    weightsRaw,
                    weightsNormalized,
                    Items = ranked.Select((c, idx) =>
                    {
                        rowLookup.TryGetValue(c.Cluster, out var r);
                        return new
                        {
                            rank = idx + 1,
                            cluster = c.Cluster,
                            score = Math.Round(c.Score, 4),
                            details = r is null ? null : new
                            {
                                region = r.Region,
                                availabilityZone = r.AvailabilityZone,
                                ageYears = r.ClusterAgeYears,
                                coreUtilization = r.CoreUtilization,
                                totalCores = r.TotalPhysicalCores,
                                usedCores = r.UsedCores,
                                totalNodes = r.TotalNodes,
                                outOfServiceNodes = r.OutOfServiceNodes,
                                hasSQL = r.HasSQL,
                                hasSLB = r.HasSLB,
                                hasWARP = r.HasWARP,
                                isHotRegion = r.IsHotRegion
                            },
                            factors = c.Factors
                                .Where(f => f.Contribution > 0.0001)
                                .OrderByDescending(f => f.Contribution)
                                .Select(f => new
                                {
                                    property = f.Property,
                                    rawValue = f.Raw,
                                    normalizedScore = Math.Round(f.Normalized, 4),
                                    weight = Math.Round(f.Weight, 4),
                                    contribution = Math.Round(f.Contribution, 4),
                                    inverted = f.Inverted,
                                    description = GetFactorDescription(f.Property)
                                })
                                .Take(12)
                                .ToList()
                        };
                    }).ToList()
                };

                return JsonSerializer.Serialize(result, JsonOpts);
            }
            catch (OperationCanceledException)
            {
                return JsonSerializer.Serialize(new ErrorDto("Operation cancelled."), JsonOpts);
            }
            catch (Exception ex)
            {
                _log?.LogError(ex, "FilterAndScoreAsync failed");
                return JsonSerializer.Serialize(new ErrorDto($"Unhandled error: {ex.Message}"), JsonOpts);
            }
        }

        // ------------------------------------------------------------------------
        // Natural-language friendly weight parsing helpers (Kernel-smart)
        // ------------------------------------------------------------------------

        private static readonly string[] AgeKeys     = { "age", "cluster age", "clusterage", "age years", "ageyears" };
        private static readonly string[] UtilKeys    = { "utilization", "util", "core utilization", "effective core utilization", "coreutilization", "effectivecoreutilization" };
        private static readonly string[] HealthKeys  = { "health", "region health", "regionhealth" };
        private static readonly string[] StrandKeys  = { "stranded", "stranded cores", "strandedcores", "stranded_ratio" };

        private static bool TryFindNumberNearAny(string text, string[] keys, out double value)
        {
            value = 0;
            foreach (var key in keys)
            {
                // KEY ... (NUMBER) or KEY ... NUMBER
                var p1 = new Regex(@"\b" + Regex.Escape(key) + @"\b[^\d%]*?[\(]?\s*(\d+(?:[.,]\d+)?)(\s*%)?\s*[\)]?",
                    RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
                var m = p1.Match(text);
                if (!m.Success)
                {
                    // NUMBER ... KEY
                    var p2 = new Regex(@"[\(]?\s*(\d+(?:[.,]\d+)?)(\s*%)?\s*[\)]?[^\w%]*?\b" + Regex.Escape(key) + @"\b",
                        RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
                    m = p2.Match(text);
                }
                if (m.Success)
                {
                    var token = m.Groups[1].Value.Replace(',', '.'); // allow "0,9"
                    if (double.TryParse(token, NumberStyles.Float, CultureInfo.InvariantCulture, out var v))
                    {
                        if (m.Groups[2].Success) v /= 100.0; // "90%" -> 0.9
                        value = v;
                        return true;
                    }
                }
            }
            return false;
        }

        private static string CanonFeature(string k) => k.Trim().ToLowerInvariant() switch
        {
            "age" or "clusterage" or "cluster age" or "age years" or "ageyears"   => "ClusterAgeYears",
            "util" or "utilization" or "core utilization" or "coreutilization"
                or "effective core utilization" or "effectivecoreutilization"     => "EffectiveCoreUtilization",
            "health" or "regionhealth" or "region health"                          => "RegionHealthScore",
            "stranded" or "strandedcores" or "stranded cores" or "stranded_ratio"  => "StrandedCoresRatio_DNG",
            _ => k
        };

        private static ScoringService.WeightConfig? ParseWeightsFlexible(string? weightsSpec)
        {
            if (string.IsNullOrWhiteSpace(weightsSpec)) return null;

            // 1) JSON
            try
            {
                var w = JsonSerializer.Deserialize<ScoringService.WeightConfig>(weightsSpec, JsonOpts);
                if (w is not null)
                {
                    var canon = new ScoringService.WeightConfig();
                    foreach (var (k, v) in w) canon[CanonFeature(k)] = v;
                    return canon;
                }
            }
            catch { /* fall through */ }

            // 2) "k=v" pairs
            var dictPairs = new ScoringService.WeightConfig();
            foreach (var part in weightsSpec.Split(',', StringSplitOptions.RemoveEmptyEntries))
            {
                var kv = part.Split('=', 2, StringSplitOptions.TrimEntries);
                if (kv.Length != 2) continue;
                if (double.TryParse(kv[1], NumberStyles.Float, CultureInfo.InvariantCulture, out var v))
                    dictPairs[CanonFeature(kv[0])] = v;
            }
            if (dictPairs.Count > 0) return dictPairs;

            // 3) Natural language extraction
            var text = weightsSpec.Trim();
            var dictNL = new ScoringService.WeightConfig();

            if (TryFindNumberNearAny(text, AgeKeys, out var age))      dictNL["ClusterAgeYears"] = age;
            if (TryFindNumberNearAny(text, UtilKeys, out var util))    dictNL["EffectiveCoreUtilization"] = util;
            if (TryFindNumberNearAny(text, HealthKeys, out var hlth))  dictNL["RegionHealthScore"] = hlth;
            if (TryFindNumberNearAny(text, StrandKeys, out var str))   dictNL["StrandedCoresRatio_DNG"] = str;

            return dictNL.Count == 0 ? null : dictNL;
        }

        /// <summary>
        /// Returns a human-readable description for scoring factors.
        /// </summary>
        private static string GetFactorDescription(string factorName) => factorName switch
        {
            // Core trio
            "ClusterAgeYears" => "Age of the cluster in years - older clusters are better candidates for decommissioning.",
            "EffectiveCoreUtilization" => "Effective core usage; lower utilization raises decom priority.",
            "RegionHealthScore" => "Region health score; poorer health raises decom priority.",

            // Health / stranding
            "OOSNodeRatio" => "Ratio of out-of-service nodes; higher suggests maintenance issues.",
            "StrandedCoresRatio_DNG" => "Cores stranded due to Do Not Grow status.",
            "StrandedCoresRatio_TIP" => "Cores stranded due to test/dev workloads.",
            "StrandedCoresRatio_32VMs" => "Cores stranded due to 32-core VM constraints.",

            // Region & timeline
            "IsHotRegion" => "Whether the cluster is in a high-demand region (penalizes decom).",
            "DecommissionYearsRemaining" => "Years until planned retirement; fewer years raises priority.",

            // Stickiness
            "HasSQL" => "Hosts SQL workloads; harder to decommission.",
            "HasSLB" => "Hosts load-balancer workloads; harder to decommission.",
            "HasWARP" => "Hosts WARP workloads; harder to decommission.",

            // Mix
            "SQL_Ratio" => "Proportion of SQL VMs.",
            "NonSpannable_Ratio" => "Proportion of non-spannable utilization.",
            "SpannableUtilizationRatio" => "Spannable utilization ratio.",
            _ => $"A factor used in decommission scoring calculations"
        };
    }
}

