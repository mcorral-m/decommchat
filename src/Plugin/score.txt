#nullable enable
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using MyM365AgentDecommision.Bot.Interfaces;
using MyM365AgentDecommision.Bot.Models;
using MyM365AgentDecommision.Bot.Services;

namespace MyM365AgentDecommision.Bot.Plugins
{
    /// <summary>
    /// Plugin providing access to scoring functionality for decommission candidates.
    /// Exposes methods to list features, score clusters, and explain scoring results.
    /// </summary>
    public sealed class ScoringPlugin
    {
        private readonly ScoringService _svc;
        private readonly IClusterDataProvider _dataProvider;

        public ScoringPlugin(ScoringService svc, IClusterDataProvider dataProvider)
        {
            _svc = svc ?? throw new ArgumentNullException(nameof(svc));
            _dataProvider = dataProvider ?? throw new ArgumentNullException(nameof(dataProvider));
        }

        /// <summary>
        /// Lists available scoring features for discoverability.
        /// </summary>
        /// <returns>A comma-separated list of feature names</returns>
        [KernelFunction]
        public string ListFeatures()
        {
            var feats = _svc.GetFeatureCatalog();
            return string.Join(", ", feats.Select(f => f.Name));
        }

        /// <summary>
        /// Trim and rebalance weights (friendly keys allowed) so the sum is 1.0.
        /// Returns the normalized weight config as JSON.
        /// </summary>
        [KernelFunction]
        public string TrimAndRebalanceWeights(string weightsSpec)
        {
            var parsed = ParseWeightsFlexible(weightsSpec) ?? ScoringService.DefaultWeights();
            var rebased = ScoringService.Rebalance(parsed);
            return JsonSerializer.Serialize(rebased, new JsonSerializerOptions { WriteIndented = true });
        }

        /// <summary>
        /// Scores and ranks clusters based on decommission criteria.
        /// Honors optional filter criteria. Supports friendly weight keys and "k=v, ..." format.
        /// Adds deterministic tie-breaking on the primary factor's raw value.
        /// Disables winsorization automatically when a single factor is weighted.
        /// </summary>
        /// <param name="topN">Number of top candidates to return.</param>
        /// <param name="weights">Optional custom weights as JSON or "k=v, ..." pairs (friendly keys allowed).</param>
        /// <param name="filterCriteria">Optional JSON criteria (ClusterFilterEngine.Criteria) to pre-filter candidates.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>JSON representation of top scoring clusters.</returns>
        [KernelFunction]
        public async Task<string> ScoreTopNAsync(
            int topN = 10,
            string? weights = null,
            string? filterCriteria = null,
            CancellationToken ct = default)
        {
            // 1) Parse weights (friendly keys allowed)
            var weightConfig = ParseWeightsFlexible(weights);

            // 2) Scoring options: if a single positive-weight factor, disable winsorization
            var options = new ScoringService.ScoringOptions();
            if (weightConfig is not null)
            {
                var active = weightConfig.Where(kv => kv.Value > 0).Select(kv => kv.Key).ToList();
                if (active.Count == 1)
                {
                    options = new ScoringService.ScoringOptions { Winsorize = false };
                }
            }

            // 3) Run scoring for all rows once (fast path, we filter after)
            var scoreResult = await _svc.ScoreAllAsync(weightConfig, options, ct);

            // 4) Load raw rows for display details and to build the allowed set (if filter provided)
            var rows = await _dataProvider.GetClusterRowDataAsync(ct);
            var clusterLookup = rows.ToDictionary(r => r.Cluster ?? r.ClusterId ?? string.Empty, StringComparer.OrdinalIgnoreCase);

            HashSet<string>? allowed = null;
            if (!string.IsNullOrWhiteSpace(filterCriteria))
            {
                try
                {
                    var crit = JsonSerializer.Deserialize<ClusterFilterEngine.Criteria>(
                        filterCriteria,
                        new JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new ClusterFilterEngine.Criteria();

                    var filtered = ClusterFilterEngine.Apply(rows, crit);
                    allowed = filtered
                        .Select(r => r.Cluster ?? r.ClusterId ?? string.Empty)
                        .ToHashSet(StringComparer.OrdinalIgnoreCase);
                }
                catch
                {
                    // swallow and treat as no filter; upstream agent may have produced partial JSON
                }
            }

            // 5) Tie-breaker setup: choose primary factor for deterministic ordering among same scores
            var primary = (weightConfig is not null && weightConfig.Count > 0)
                ? weightConfig.OrderByDescending(kv => kv.Value).First().Key
                : "ClusterAgeYears";

            double TieKey(ScoringService.ScoreRowBreakdown r)
            {
                var f = r.Factors.FirstOrDefault(x => string.Equals(x.Property, primary, StringComparison.OrdinalIgnoreCase));
                if (f is null || f.Raw is null) return double.NaN;
                return f.Inverted ? -f.Raw.Value : f.Raw.Value;
            }

            // 6) Rank, filter, take N
            var ranked = scoreResult.Rankings
                .Where(r => allowed is null || allowed.Contains(r.Cluster))
                .OrderByDescending(r => r.Score)
                .ThenByDescending(r => TieKey(r))
                .Take(Math.Min(topN, allowed?.Count ?? scoreResult.Rankings.Count))
                .ToList();

            // 7) Build response payload
            var responseObj = new
            {
                clusters = ranked.Select((c, idx) =>
                {
                    clusterLookup.TryGetValue(c.Cluster, out var row);
                    return new
                    {
                        rank = idx + 1,
                        cluster = c.Cluster,
                        score = Math.Round(c.Score, 4),
                        details = row is null ? null : new
                        {
                            region = row.Region,
                            availabilityZone = row.AvailabilityZone,
                            ageYears = row.ClusterAgeYears,
                            coreUtilization = row.CoreUtilization,
                            totalCores = row.TotalPhysicalCores,
                            usedCores = row.UsedCores,
                            totalNodes = row.TotalNodes,
                            outOfServiceNodes = row.OutOfServiceNodes,
                            hasSQL = row.HasSQL,
                            hasWARP = row.HasWARP,
                            hasSLB = row.HasSLB,
                            isHotRegion = row.IsHotRegion
                        },
                        factors = c.Factors
                            .Where(f => f.Contribution > 0.0001)
                            .OrderByDescending(f => f.Contribution)
                            .Select(f => new
                            {
                                property = f.Property,
                                rawValue = f.Raw,
                                normalizedScore = Math.Round(f.Normalized, 4),
                                weight = Math.Round(f.Weight, 4),
                                contribution = Math.Round(f.Contribution, 4),
                                inverted = f.Inverted,
                                description = GetFactorDescription(f.Property)
                            })
                            .Take(12)
                            .ToList()
                    };
                }).ToList(),
                summary = new
                {
                    totalConsidered = scoreResult.Rankings.Count,
                    returned = ranked.Count,
                    topNRequested = topN,
                    primaryFactor = primary,
                    weightsApplied = weightConfig ?? ScoringService.DefaultWeights()
                }
            };

            return JsonSerializer.Serialize(responseObj, new JsonSerializerOptions { WriteIndented = true });
        }

        // ------------------------------- Helpers --------------------------------

        /// <summary>
        /// Map friendly factor names to canonical feature keys used by ScoringService.
        /// </summary>
        private static string CanonFeature(string k) => k.Trim().ToLowerInvariant() switch
        {
            "age" or "clusterage" or "ageyears"                  => "ClusterAgeYears",
            "util" or "utilization" or "coreutilization"        => "EffectiveCoreUtilization",
            "health" or "regionhealth"                           => "RegionHealthScore",
            "stranded" or "strandedcores" or "stranded_ratio"   => "StrandedCoresRatio_DNG",
            _ => k
        };

        /// <summary>
        /// Parse weights from JSON or "k=v, ..." pairs, accepting friendly keys.
        /// Returns null if nothing parseable is found.
        /// </summary>
        private static ScoringService.WeightConfig? ParseWeightsFlexible(string? weightsSpec)
        {
            if (string.IsNullOrWhiteSpace(weightsSpec)) return null;

            // 1) Try JSON directly
            try
            {
                var w = JsonSerializer.Deserialize<ScoringService.WeightConfig>(weightsSpec);
                if (w is not null)
                {
                    var canon = new ScoringService.WeightConfig();
                    foreach (var (k, v) in w)
                        canon[CanonFeature(k)] = v;
                    return canon;
                }
            }
            catch { /* fall through to k=v parsing */ }

            // 2) Try "k=v, k=v" format
            var dict = new ScoringService.WeightConfig();
            foreach (var part in weightsSpec.Split(',', StringSplitOptions.RemoveEmptyEntries))
            {
                var kv = part.Split('=', 2, StringSplitOptions.TrimEntries);
                if (kv.Length != 2) continue;
                if (double.TryParse(kv[1], NumberStyles.Float, CultureInfo.InvariantCulture, out var v))
                {
                    dict[CanonFeature(kv[0])] = v;
                }
            }

            return dict.Count == 0 ? null : dict;
        }

        /// <summary>
        /// Returns a human-readable description for the known scoring factors.
        /// </summary>
        private static string GetFactorDescription(string factorName) => factorName switch
        {
            // Core trio
            "ClusterAgeYears" => "Age of the cluster in years (older → higher score).",
            "EffectiveCoreUtilization" => "Effective core usage; lower utilization raises decom priority.",
            "RegionHealthScore" => "Region health score; poorer health raises decom priority.",

            // Health / stranding
            "OOSNodeRatio" => "Ratio of out-of-service nodes; higher suggests maintenance issues.",
            "StrandedCoresRatio_DNG" => "Cores stranded due to Do Not Grow status.",
            "StrandedCoresRatio_TIP" => "Cores stranded due to test/dev workloads.",
            "StrandedCoresRatio_32VMs" => "Cores stranded due to 32-core VM constraints.",

            // Region & timeline
            "IsHotRegion" => "Whether the cluster is in a high-demand region (penalizes decom).",
            "DecommissionYearsRemaining" => "Years until planned retirement; fewer years raises priority.",

            // Stickiness
            "HasSQL" => "Hosts SQL workloads; harder to decommission.",
            "HasPlatformTenant" => "Hosts platform tenants; harder to decommission.",
            "HasSLB" => "Hosts load-balancer workloads; harder to decommission.",
            "HasWARP" => "Hosts WARP workloads; harder to decommission.",
            "HasUDGreaterThan10" => "High update-domain count; migration risk.",
            "HasInstancesGreaterThan10" => "High instance count; migration effort.",

            // Mix
            "SQL_Ratio" => "Proportion of SQL VMs.",
            "NonSpannable_Ratio" => "Proportion of non-spannable utilization.",
            "SpannableUtilizationRatio" => "Spannable utilization ratio.",
            _ => $"Scoring factor: {factorName}"
        };
    }
}
