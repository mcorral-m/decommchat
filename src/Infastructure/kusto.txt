// KustoSdkDataProvider.cs
using System;
using System.IO;
using System.Linq;
using System.Data;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using Microsoft.Extensions.Logging;
using MyM365AgentDecommision.Bot.Models;
using MyM365AgentDecommision.Bot.Interfaces;

// Kusto SDK
using Kusto.Data;
using Kusto.Data.Common;
using Kusto.Data.Net.Client;

namespace MyM365AgentDecommision.Infrastructure.Kusto;

// New: Activity context abstraction
public interface IActivityContext
{
    T GetSetting<T>(string key);
    object? GetActiveTraceSource();
    object? GetManagedTenantCert();
}

// New: Enum for Kusto configurations
public enum KustoConfig
{
    AzureDCM,
    OneCapacity,
    // Add more as needed
}

// New: Kusto configuration struct
public struct KustoConfiguration
{
    public string Cluster { get; }
    public string Database { get; }
    public bool IsPublicOnly { get; }
    public KustoConfiguration(string cluster, string database, bool isPublicOnly)
    {
        Cluster = cluster;
        Database = database;
        IsPublicOnly = isPublicOnly;
    }
}

// New: IKustoQueryHelper interface
public interface IKustoQueryHelper : IDisposable
{
    Task<IDataReader> ExecuteQueryAsync(string query, CancellationToken ct = default);
    // Add more as needed
}

// New: IKustoQueryHelperFactory interface
public interface IKustoQueryHelperFactory
{
    IKustoQueryHelper CreateHelper(IActivityContext context, KustoConfig kustoConfig);
    IKustoQueryHelper CreateCustomHelper(IActivityContext context, string kustoCluster, string kustoDatabase, bool isPublicOnly);
    IKustoQueryHelper CreateHelperForAadUser(IActivityContext context, string kustoCluster);
}

// Cloud environment types
public enum CloudEnvironment
{
    Public,
    Government,
    China,
    Germany
}

// Simple activity context implementation
public class DefaultActivityContext : IActivityContext
{
    private readonly Dictionary<string, object> _settings;
    private readonly object? _traceSource;
    private readonly object? _managedTenantCert;

    public DefaultActivityContext(Dictionary<string, object> settings, object? traceSource = null, object? managedTenantCert = null)
    {
        _settings = settings ?? new Dictionary<string, object>();
        _traceSource = traceSource;
        _managedTenantCert = managedTenantCert;
    }

    public T GetSetting<T>(string key)
    {
        if (_settings.TryGetValue(key, out var value) && value is T typedValue)
        {
            return typedValue;
        }
        return default(T)!;
    }

    public object? GetActiveTraceSource() => _traceSource;
    public object? GetManagedTenantCert() => _managedTenantCert;
}

// Kusto query helper implementation
public class KustoQueryHelper : IKustoQueryHelper, IDisposable
{
    private readonly ICslQueryProvider _queryProvider;
    private readonly ILogger? _logger;

    public KustoQueryHelper(ICslQueryProvider queryProvider, ILogger? logger = null)
    {
        _queryProvider = queryProvider ?? throw new ArgumentNullException(nameof(queryProvider));
        _logger = logger;
    }

    public async Task<IDataReader> ExecuteQueryAsync(string query, CancellationToken ct = default)
    {
        try
        {
            var props = new ClientRequestProperties();
            if (ct != CancellationToken.None)
            {
                props.ClientRequestId = Guid.NewGuid().ToString();
            }

            return await _queryProvider.ExecuteQueryAsync(string.Empty, query, props);
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Failed to execute Kusto query");
            throw;
        }
    }

    public void Dispose()
    {
        _queryProvider?.Dispose();
    }
}

// Remote Kusto query helper (for cross-cloud scenarios)
public class RemoteKustoQueryHelper : IKustoQueryHelper, IDisposable
{
    private readonly IActivityContext _context;
    private readonly string _kustoCluster;
    private readonly string _kustoDatabase;
    private ICslQueryProvider? _queryProvider;

    public RemoteKustoQueryHelper(IActivityContext context, string kustoCluster, string kustoDatabase)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _kustoCluster = kustoCluster ?? throw new ArgumentNullException(nameof(kustoCluster));
        _kustoDatabase = kustoDatabase ?? throw new ArgumentNullException(nameof(kustoDatabase));
    }

    public async Task<IDataReader> ExecuteQueryAsync(string query, CancellationToken ct = default)
    {
        if (_queryProvider == null)
        {
            var connectionString = new KustoConnectionStringBuilder(_kustoCluster)
                .WithAadUserPromptAuthentication();
            _queryProvider = KustoClientFactory.CreateCslQueryProvider(connectionString);
        }

        var props = new ClientRequestProperties();
        return await _queryProvider.ExecuteQueryAsync(_kustoDatabase, query, props);
    }

    public void Dispose()
    {
        _queryProvider?.Dispose();
    }
}

// Factory implementation with cloud-specific logic
public class DynamicKustoQueryHelperFactory : IKustoQueryHelperFactory
{
    private readonly ILogger<DynamicKustoQueryHelperFactory>? _logger;

    public DynamicKustoQueryHelperFactory(ILogger<DynamicKustoQueryHelperFactory>? logger = null)
    {
        _logger = logger;
    }

    public IKustoQueryHelper CreateHelper(IActivityContext context, KustoConfig kustoConfig)
    {
        if (!KustoConfigurations.TryGetValue(kustoConfig, out var config))
        {
            throw new ArgumentException($"Invalid config type: {kustoConfig}", nameof(kustoConfig));
        }

        string kustoCluster = context.GetSetting<string>(config.Cluster) ?? GetDefaultClusterUri(kustoConfig);
        string kustoDatabase = context.GetSetting<string>(config.Database) ?? GetDefaultDatabase(kustoConfig);

        return CreateCustomHelper(context, kustoCluster, kustoDatabase, config.IsPublicOnly);
    }

    public IKustoQueryHelper CreateCustomHelper(IActivityContext context, string kustoCluster, string kustoDatabase, bool isPublicOnly)
    {
        if (string.IsNullOrWhiteSpace(kustoCluster))
            throw new ArgumentException("Kusto cluster cannot be null or empty", nameof(kustoCluster));
        if (string.IsNullOrWhiteSpace(kustoDatabase))
            throw new ArgumentException("Kusto database cannot be null or empty", nameof(kustoDatabase));

        // Get cloud environment
        string cloudName = context.GetSetting<string>("CloudName") ?? "Public";
        bool isPublicCloud = cloudName.Equals(CloudEnvironment.Public.ToString(), StringComparison.OrdinalIgnoreCase);
        
        // Use remote helper for cross-cloud scenarios
        if (isPublicOnly && !isPublicCloud)
        {
            return new RemoteKustoQueryHelper(context, kustoCluster, kustoDatabase);
        }

        // Try certificate-based authentication first
        var managedTenantCert = context.GetManagedTenantCert();
        if (managedTenantCert != null)
        {
            string appId = context.GetSetting<string>("AppId") ?? string.Empty;
            string authority = context.GetSetting<string>("Authority") ?? "https://login.microsoftonline.com/";
            
            return CreateCertificateBasedHelper(kustoCluster, kustoDatabase, appId, authority, managedTenantCert);
        }

        // Fall back to managed identity or user prompt
        return CreateFallbackHelper(kustoCluster, kustoDatabase);
    }

    public IKustoQueryHelper CreateHelperForAadUser(IActivityContext context, string kustoCluster)
    {
        if (string.IsNullOrWhiteSpace(kustoCluster))
            throw new ArgumentException("Kusto cluster cannot be null or empty", nameof(kustoCluster));

        var connectionString = new KustoConnectionStringBuilder(kustoCluster)
            .WithAadUserPromptAuthentication();
        
        var queryProvider = KustoClientFactory.CreateCslQueryProvider(connectionString);
        return new KustoQueryHelper(queryProvider, _logger);
    }

    private IKustoQueryHelper CreateCertificateBasedHelper(string kustoCluster, string kustoDatabase, string appId, string authority, object managedTenantCert)
    {
        try
        {
            // In a real implementation, you would use the certificate for authentication
            // For now, fall back to managed identity
            var connectionString = new KustoConnectionStringBuilder(kustoCluster)
                .WithAadSystemManagedIdentity();
            
            var queryProvider = KustoClientFactory.CreateCslQueryProvider(connectionString);
            return new KustoQueryHelper(queryProvider, _logger);
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Certificate-based authentication failed, falling back to managed identity");
            return CreateFallbackHelper(kustoCluster, kustoDatabase);
        }
    }

    private IKustoQueryHelper CreateFallbackHelper(string kustoCluster, string kustoDatabase)
    {
        KustoConnectionStringBuilder connectionString;
        
        try
        {
            // Try managed identity first
            connectionString = new KustoConnectionStringBuilder(kustoCluster)
                .WithAadSystemManagedIdentity();
        }
        catch
        {
            // Fall back to user prompt
            connectionString = new KustoConnectionStringBuilder(kustoCluster)
                .WithAadUserPromptAuthentication();
        }
        
        var queryProvider = KustoClientFactory.CreateCslQueryProvider(connectionString);
        return new KustoQueryHelper(queryProvider, _logger);
    }

    private static string GetDefaultClusterUri(KustoConfig config) => config switch
    {
        KustoConfig.AzureDCM => "https://azuredcm.kusto.windows.net",
        KustoConfig.OneCapacity => "https://onecapacityfollower.centralus.kusto.windows.net",
        _ => throw new ArgumentException($"No default cluster URI for config: {config}")
    };

    private static string GetDefaultDatabase(KustoConfig config) => config switch
    {
        KustoConfig.AzureDCM => "AzureDCMDb",
        KustoConfig.OneCapacity => "Shared",
        _ => throw new ArgumentException($"No default database for config: {config}")
    };

    // Configuration dictionary mapping
    private static readonly Dictionary<KustoConfig, KustoConfiguration> KustoConfigurations = new()
    {
        { KustoConfig.AzureDCM, new KustoConfiguration("AzureDcmCluster", "AzureDcmDatabase", isPublicOnly: false) },
        { KustoConfig.OneCapacity, new KustoConfiguration("OneCapacityCluster", "OneCapacityDatabase", isPublicOnly: true) }
    };
}

/// <summary>
/// Refactored provider that uses the factory pattern for Kusto connections
/// and supports certificate-based authentication with cloud-specific logic.
/// </summary>
public class KustoSdkDataProvider : IClusterDataProvider, IDisposable
{
    private readonly ILogger<KustoSdkDataProvider> _logger;
    private readonly IKustoQueryHelperFactory _factory;
    private readonly IActivityContext _context;
    private readonly TimeSpan _defaultTimeout;
    
    // Lazy-loaded query helpers
    private IKustoQueryHelper? _dcmHelper;
    private IKustoQueryHelper? _onecapHelper;
    
    // Keep embedded query as fallback
    private static readonly string EmbeddedQuery = @"
// Gen4 Comprehensive Query with cross-cluster joins
let clusters = cluster('azuredcm.kusto.windows.net').database('AzureDCMDb').Gen4Clusters
| where Cluster != '' and ClusterId != ''
| project ClusterId = tostring(ClusterId), Cluster = tostring(Cluster), Region = tostring(Region);
// ... rest of embedded query
clusters";

    public KustoSdkDataProvider(
        ILogger<KustoSdkDataProvider> logger,
        IKustoQueryHelperFactory factory,
        IActivityContext context,
        TimeSpan? defaultTimeout = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _factory = factory ?? throw new ArgumentNullException(nameof(factory));
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _defaultTimeout = defaultTimeout ?? TimeSpan.FromMinutes(5);
    }

    // Lazy initialization of query helpers using factory
    private IKustoQueryHelper GetDcmHelper()
    {
        return _dcmHelper ??= _factory.CreateHelper(_context, KustoConfig.AzureDCM);
    }

    private IKustoQueryHelper GetOnecapHelper()
    {
        return _onecapHelper ??= _factory.CreateHelper(_context, KustoConfig.OneCapacity);
    }        private static KustoConnectionStringBuilder BuildConnection(
            string clusterUri,
            bool useManagedIdentity,
            string? tenantId,
            string? clientId,
            string? clientSecret,
            TimeSpan? defaultTimeout)
        {
            if (string.IsNullOrWhiteSpace(clusterUri))
                throw new ArgumentException("clusterUri is required");

            KustoConnectionStringBuilder csb;

            if (useManagedIdentity)
            {
                // Managed Identity (best in Azure)
                csb = new KustoConnectionStringBuilder(clusterUri)
                    .WithAadSystemManagedIdentity();
            }
            else if (!string.IsNullOrWhiteSpace(clientId) && !string.IsNullOrWhiteSpace(clientSecret) && !string.IsNullOrWhiteSpace(tenantId))
            {
                // App registration (Client Credentials)
                csb = new KustoConnectionStringBuilder(clusterUri)
                    .WithAadApplicationKeyAuthentication(clientId, clientSecret, tenantId);
            }
            else
            {
                // Fallback to user auth (device code)
                csb = new KustoConnectionStringBuilder(clusterUri)
                    .WithAadUserPromptAuthentication();
            }

            if (defaultTimeout is { } t)
            {
                // Set application name and timeout using connection string properties
                var props = new ClientRequestProperties();
                props.SetOption(ClientRequestProperties.OptionServerTimeout, t);
                // Connection string builder doesn't need to be modified for timeout
            }

            return csb;
        }

    public void Dispose()
    {
        _dcmHelper?.Dispose();
        _onecapHelper?.Dispose();
    }        // ------------------------------------------------------------
        // Public API
        // ------------------------------------------------------------

        public async Task<List<ClusterData>> GetClusterDataAsync()
        {
            return await GetClusterDataWithCancellationAsync(CancellationToken.None);
        }

        private async Task<List<ClusterData>> GetClusterDataWithCancellationAsync(CancellationToken ct)
        {
            _logger.LogInformation("Running comprehensive Gen4 cluster query...");

            // The comprehensive query uses cross-cluster references; execute against OneCapacity (Shared).
            using var onecapHelper = GetOnecapHelper();
            using var reader = await onecapHelper.ExecuteQueryAsync(GetGen4ClusterQuery(), ct);
            var col = GetColumnMappings(reader);

            var list = new List<ClusterData>();
            while (reader.Read())
                list.Add(MapReaderToClusterData(reader, col));

            _logger.LogInformation("Returned {Count} clusters", list.Count);
            return list;
        }


        public async Task<bool> TestConnectionAsync(CancellationToken ct = default)
        {
            try
            {
                // Light-weight ‚Äú.show database‚Äù pings ‚Äî one call per cluster
                var ok1 = await TestHelperAsync(GetDcmHelper(), ct);
                var ok2 = await TestHelperAsync(GetOnecapHelper(), ct);
                return ok1 && ok2;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Kusto connectivity test failed");
                return false;
            }
        }
        

        public async Task<string> GetDataSourceInfoAsync(CancellationToken ct = default)
    {
        var ok = await TestConnectionAsync(ct);
        var stamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss 'UTC'");
        return $"üìä Kusto Data Source\n" +
               $"- AzureDCMDb: configured (test: {(ok ? "‚úÖ" : "‚ùå")})\n" +
               $"- OneCapacity/Shared: configured (test: {(ok ? "‚úÖ" : "‚ùå")})\n" +
               $"- Generated: {stamp}";
    }

        // Convenience for plugin layer
        public async Task<List<ClusterRow>> GetClusterRowDataAsync(CancellationToken ct = default)
            => (await GetClusterDataWithCancellationAsync(ct)).Select(ConvertToClusterRow).ToList();

        public async Task<ClusterData?> GetClusterDetailsAsync(string clusterId, CancellationToken ct = default)
        {
            _logger.LogInformation("Getting details for cluster {ClusterId}", clusterId);
            
            // Retrieve all clusters and find the one matching the provided ID
            var allClusters = await GetClusterDataWithCancellationAsync(ct);
            return allClusters.FirstOrDefault(c => string.Equals(c.ClusterId, clusterId, StringComparison.OrdinalIgnoreCase));
        }

        public async Task<ClusterRow?> GetClusterRowDetailsAsync(string clusterId, CancellationToken ct = default)
            => (await GetClusterDetailsAsync(clusterId, ct)) is { } c ? ConvertToClusterRow(c) : null;

        // ------------------------------------------------------------
        // Internal helpers
        // ------------------------------------------------------------
        
        /// <summary>Helper method to test connection using factory pattern</summary>
        private static async Task<bool> TestHelperAsync(IKustoQueryHelper helper, CancellationToken ct)
        {
            try
            {
                using var reader = await helper.ExecuteQueryAsync("print 'connection_test'", ct);
                return reader != null;
            }
            catch (Exception)
            {
                return false;
            }
        }

        private static async Task<bool> TestAsync(ICslQueryProvider qp, string database, CancellationToken ct)
        {
            using var reader = await qp.ExecuteQueryAsync(database, ".show tables | take 1", null, ct);
            return reader != null;
        }

        private static async Task<IDataReader> ExecuteQueryAsync(
            ICslQueryProvider qp,
            string database,
            string query,
            ClientRequestProperties? props,
            CancellationToken ct)
        {
            // Simple retry (3x) ‚Äì you can replace with Polly if you want
            const int maxRetries = 3;
            for (int attempt = 1; attempt <= maxRetries; attempt++)
            {
                try
                {
                    var rdr = await qp.ExecuteQueryAsync(database, query, props, ct);
                    return rdr;
                }
                catch (Exception) when (attempt < maxRetries)
                {
                    await Task.Delay(TimeSpan.FromMilliseconds(200 * attempt), ct);
                    continue;
                }
            }

            // If we get here, last attempt threw; re-throw by executing once more outside catch
            return await qp.ExecuteQueryAsync(database, query, props, ct);
        }

        /// <summary>Loads the KQL from file if present; falls back to embedded query.</summary>
        private string GetGen4ClusterQuery()
        {
            // Try multiple paths to find the query file
            var possiblePaths = new[]
            {
                // Standard path relative to base directory
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "src", "Queries", "GEN4QUERY.klq"),
                
                // Path relative to the project root (going up from bin/Debug/net9.0)
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "src", "Queries", "GEN4QUERY.klq"),
                
                // Absolute path to the source directory
                Path.Combine(Directory.GetCurrentDirectory(), "src", "Queries", "GEN4QUERY.klq")
            };

            foreach (var filePath in possiblePaths)
            {
                _logger.LogInformation("Looking for query file at: {FilePath}", filePath);
                
                if (File.Exists(filePath))
                {
                    try
                    {
                        _logger.LogInformation("Found query file, loading content from {FilePath}", filePath);
                        string content = File.ReadAllText(filePath);
                        _logger.LogInformation("Successfully loaded query file ({Length} characters)", content.Length);
                        return content;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, "Failed to read query file at {FilePath}, trying next path", filePath);
                    }
                }
                else
                {
                    _logger.LogWarning("Query file not found at {FilePath}", filePath);
                }
            }

            // Fallback: embedded validated comprehensive query with dual-mode tenant analysis
            _logger.LogInformation("Using embedded query fallback as no file was found");
            return """
// ============================================================================
// MAIN: Util + Props + Tenant  +  Hot Regions (per Region)  +  Regional Health
//  - RegionHotnessPriority is assigned by Region (no default 999)
//  - Uses GLOBAL LATEST snapshot of hot regions (one row per Region)
// ============================================================================
// STEP 1: Gen4 clusters
let Gen4WithoutDecomPair =
cluster('azuredcm.kusto.windows.net').database('AzureDCMDb').dcmInventoryGenerationMappingV3
| where ClusterType == 'Compute'
| extend MajorGeneration = tostring(split(Generation, '.')[0])
| summarize GenerationList = array_strcat(array_sort_asc(make_set(MajorGeneration)), ',') by ClusterName = ClusterId
| where GenerationList == '4'
| distinct ClusterName
;
// STEP 2: Utilization & infra (no ACU / no TiP node analytics)
let ClusterUtilizationData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared').EfficiencyTracker_Get_LatestDecommInsights
| where Cluster in (Gen4WithoutDecomPair)
| summarize
    TotalCore=todouble(sum(TotalPhysicalCores)),
    UsedCore=todouble(sum(UsedCores)),
    UsedSQL=todouble(sum(UsedCores_SQL)),
    UsedNonSQL=todouble(sum(UsedCores_NonSQL)),
    UsedNonSQL_Spannable=todouble(sum(UsedCores_NonSQL_Spannable)),
    UsedNonSQL_NonSpannable=todouble(sum(UsedCores_NonSQL_NonSpannable)),
    VMCount=sum(VMCount),
    VMCount_SQL=sum(VMCount_SQL),
    VMCount_NonSQL=sum(VMCount_NonSQL),
    VMCount_NonSQL_Spannable=sum(VMCount_NonSQL_Spannable),
    VMCount_NonSQL_NonSpannable=sum(VMCount_NonSQL_NonSpannable),
    MaxSupportedVMs=sum(MaxSupportedVMs),
    Nodes=sum(NodeCount),
    RackCount=sum(RackCount),
    OutOfServices=sum(NodeCount_OOS),
    DNG_Nodes=sum(NodeCount_DNG),
    StrandedCores_DNG=todouble(sum(StrandedPhysicalCores_DNG)),
    StrandedCores_TIP=todouble(sum(StrandedPhysicalCores_TIP)),
    NodeCount_IOwnMachine=sum(NodeCount_IOwnMachine),
    NodeCount_32VMs=sum(NodeCount_32VMs),
    StrandedCores_32VMs=todouble(sum(StrandedPhysicalCores_32VMs)),
    PhysicalCoresPerNode=any(PhysicalCoresPerNode),
    MPCountInCluster=any(MPCountInCluster),
    RackCountInCluster=any(RackCountInCluster),
    IsLive=any(IsLive),
    ClusterType=any(ClusterType),
    IsTargetMP=any(IsTargetMP),
    TenantWithMaxFD=any(TenantNameWithMaxFDCountInCluster),
    Generation=any(Generation),
    Manufacturer=any(Manufacturer),
    MemCategory=any(MemCategory),
    IsSpecialtySKU=any(IsSpecialtySKU),
    TransitionSKUCategory=any(TransitionSKUCategory)
    by Cluster
| extend 
    CoreUtilization = round(UsedCore / TotalCore * 100, 2),
    VMDensity = round(todouble(VMCount) / MaxSupportedVMs * 100, 2),
    OutOfServicesPercentage = round(todouble(OutOfServices) / Nodes * 100, 2),
    SQL_Ratio = round(UsedSQL / UsedCore * 100, 2),
    NonSpannable_Ratio = round(UsedNonSQL_NonSpannable / UsedNonSQL * 100, 2),
    SpannableUtilizationRatio = round(UsedNonSQL_Spannable / (UsedNonSQL_Spannable + UsedNonSQL_NonSpannable) * 100, 2),
    HealthyNodeRatio = round(todouble(Nodes - OutOfServices - DNG_Nodes) / Nodes * 100, 2),
    EffectiveCoreUtilization = round((UsedCore - StrandedCores_DNG - StrandedCores_TIP) / TotalCore * 100, 2)
;
// STEP 3: Cluster properties & age (gives us Region)
let ClusterPropertiesData =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._CCC_Cache_ClusterProperties
| where Cluster in (Gen4WithoutDecomPair)
| where isnotempty(ClusterLIVEDate)
| summarize arg_max(PreciseTimeStamp, *) by Cluster
| extend 
    ClusterAgeDays  = datetime_diff('day', now(), ClusterLIVEDate),
    ClusterAgeYears = round(todouble(datetime_diff('day', now(), ClusterLIVEDate)) / 365.25, 1),
    DecommissionTimeRemaining   = datetime_diff('day', ClusterDecommisionDate, now()),
    DecommissionYearsRemaining  = round(todouble(datetime_diff('day', ClusterDecommisionDate, now())) / 365.25, 1)
| project Cluster, Region, DC, AvailabilityZone, PhysicalAZ, 
    ClusterAgeDays, ClusterAgeYears, DecommissionTimeRemaining, DecommissionYearsRemaining,
    Generation, Manufacturer, MemCategory, CloudType, RegionType, Intent, IntentIsSellable,
    SKUName, Servers, NumRacks, IsUltraSSDEnabled, IsSpecialtySKU
;
// STEP 4: Tenant/platform workload
let TenantWorkloadData =
LogTenantSnapshot
| where PreciseTimeStamp > ago(2h)
| where Tenant in (Gen4WithoutDecomPair)
| extend NonGuidTenant = isnull(toguid(tenantName))
| summarize arg_max(PreciseTimeStamp, *) by Tenant, tenantName
| extend TenantInfo = strcat(tenantName, ':#', numRoleInstances, ':U-', maxUpdateDomain)
| extend HasUDGreaterThan10 = iff(toint(maxUpdateDomain) > 10, long(1), long(0))
| extend HasInstancesGreaterThan10 = iff(toint(numRoleInstances) > 10, long(1), long(0))
| summarize 
    GuidTenant=countif(NonGuidTenant == false),
    MaxUpdateDomain = maxif(maxUpdateDomain, NonGuidTenant == true),
    TenantList=array_strcat(array_sort_asc(make_set_if(TenantInfo, NonGuidTenant == true)), ','),
    HasUDGreaterThan10=iff(sum(HasUDGreaterThan10) > 0, true, false),
    HasInstancesGreaterThan10=iff(sum(HasInstancesGreaterThan10) > 0, true, false),
    TotalInstances=sum(toint(numRoleInstances)),
    TenantCount=count()
    by Tenant
| extend 
    HasSLB = iff(TenantList contains 'slb', true, false),
    HasWARP = iff(TenantList contains 'warp', true, false),
    HasPlatformTenant = isnotempty(TenantList),
    HasSQL = false
| project Tenant, HasPlatformTenant, HasWARP, HasSLB, HasSQL, HasUDGreaterThan10, HasInstancesGreaterThan10, 
    TotalInstances, TenantCount
;
// STEP 5: Hot Regions ‚Äî GLOBAL LATEST snapshot (normalize Region for join)
let HotRegions_Snapshot =
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._Cache_Fraud_RegionPrioritization
| where Reason == "Hot Region"
| as HR
| where TimeStamp == toscalar(HR | summarize max(TimeStamp))
| summarize
    RegionHotnessPriority = min(Priority),
    LatestHotTimestamp   = max(TimeStamp),
    HotRegionVMSeriesD   = make_set(VMSeries)
  by Region
| extend HotRegionVMSeries = array_strcat(HotRegionVMSeriesD, ','),
         RegionKey = tolower(trim(' ', Region))
| project RegionKey, Region, RegionHotnessPriority, HotRegionVMSeries, LatestHotTimestamp
;
// STEP 6: Regional health (latest 1d; normalize Region too)
let RegionalHealthData =  
cluster('onecapacityfollower.centralus.kusto.windows.net').database('Shared')._CCC_Cache_RegionHealthLevel_Prediction
| where PreciseTimeStamp >= ago(1d)
| summarize arg_max(PreciseTimeStamp, *) by Region
| extend RegionKey = tolower(trim(' ', Region))
| project RegionKey, Region,
         RegionHealthScore = ProjectedRegionHealthScore,
         RegionHealthLevel = ProjectedRegionHealthLevel,
         RegionHealthProjectedTime
;
// STEP 7: Build base (util + tenant + props), then join by RegionKey
ClusterUtilizationData
| join kind=inner     TenantWorkloadData  on $left.Cluster == $right.Tenant
| join kind=leftouter ClusterPropertiesData on $left.Cluster == $right.Cluster
| extend RegionKey = tolower(trim(' ', tostring(Region)))   // normalize for join
| join kind=leftouter HotRegions_Snapshot on RegionKey
| join kind=leftouter RegionalHealthData  on RegionKey
| extend
    // no defaulting of RegionHotnessPriority; just boolean flag
    IsHotRegion = iff(isnotempty(RegionHotnessPriority), true, false),
    // fills for core props only
    ClusterAgeDays = coalesce(ClusterAgeDays, long(-1)),
    ClusterAgeYears = coalesce(ClusterAgeYears, -1.0),
    DecommissionYearsRemaining = coalesce(DecommissionYearsRemaining, -1.0),
    HasSQL = iff(UsedSQL > 0, true, false),
    Region = coalesce(Region, ''),
    AvailabilityZone = coalesce(AvailabilityZone, ''),
    DC = coalesce(DC, ''),
    PhysicalAZ = coalesce(PhysicalAZ, ''),
    Generation = iff(isempty(Generation), '', Generation),
    Manufacturer = iff(isempty(Manufacturer), '', Manufacturer),
    MemCategory = iff(isempty(MemCategory), '', MemCategory),
    SKUName = iff(isempty(SKUName), '', SKUName),
    CloudType = iff(isempty(CloudType), '', CloudType),
    RegionType = iff(isempty(RegionType), '', RegionType),
    Intent = iff(isempty(Intent), '', Intent),
    IntentIsSellable = iff(isempty(IntentIsSellable), '', IntentIsSellable),
    TransitionSKUCategory = iff(isempty(TransitionSKUCategory), '', TransitionSKUCategory),
    ClusterType = iff(isempty(ClusterType), '', ClusterType),
    TenantWithMaxFD = iff(isempty(TenantWithMaxFD), '', TenantWithMaxFD),
    Servers = coalesce(Servers, long(0)),
    NumRacks = coalesce(NumRacks, long(0)),
    IsUltraSSDEnabled = coalesce(IsUltraSSDEnabled, false),
    IsSpecialtySKU = coalesce(IsSpecialtySKU, false),
    PhysicalCoresPerNode = coalesce(PhysicalCoresPerNode, long(0)),
    MPCountInCluster = coalesce(MPCountInCluster, long(0)),
    RackCountInCluster = coalesce(RackCountInCluster, long(0)),
    IsLive = coalesce(IsLive, true),
    IsTargetMP = coalesce(IsTargetMP, false),
    NodeCount_IOwnMachine = coalesce(NodeCount_IOwnMachine, long(0)),
    NodeCount_32VMs = coalesce(NodeCount_32VMs, long(0)),
    StrandedCores_32VMs = coalesce(StrandedCores_32VMs, 0.0)
| project
    // Identity & location
    ClusterId = Cluster,
    Region, AvailabilityZone, DataCenter = DC, PhysicalAZ,
    // Age & timeline
    ClusterAgeYears, ClusterAgeDays, DecommissionYearsRemaining, Intent, IntentIsSellable,
    // HW / SKU
    Generation, Manufacturer, MemCategory, SKUName, Servers, NumRacks,
    IsUltraSSDEnabled, IsSpecialtySKU, CloudType, RegionType, TransitionSKUCategory,
    // Infra details
    PhysicalCoresPerNode, MPCountInCluster, RackCountInCluster, IsLive, ClusterType, IsTargetMP,
    // Core Utilization
    TotalPhysicalCores = TotalCore, UsedCores = UsedCore, UsedCores_SQL = UsedSQL, 
    UsedCores_NonSQL = UsedNonSQL, UsedCores_NonSQL_Spannable = UsedNonSQL_Spannable,
    UsedCores_NonSQL_NonSpannable = UsedNonSQL_NonSpannable, CoreUtilization,
    // VM & capacity
    VMCount, VMCount_SQL, VMCount_NonSQL, VMCount_NonSQL_Spannable, VMCount_NonSQL_NonSpannable,
    MaxSupportedVMs, VMDensity,
    // Health
    TotalNodes = Nodes, OutOfServiceNodes = OutOfServices, DNG_Nodes,
    StrandedCores_DNG, StrandedCores_TIP, OutOfServicesPercentage,
    NodeCount_IOwnMachine, NodeCount_32VMs, StrandedCores_32VMs,
    // Workload / tenant
    HasPlatformTenant, HasWARP, HasSLB, HasSQL, HasUDGreaterThan10, HasInstancesGreaterThan10,
    TotalInstances, TenantCount, TenantWithMaxFD,
    // Efficiency ratios
    SQL_Ratio, NonSpannable_Ratio, SpannableUtilizationRatio, HealthyNodeRatio, EffectiveCoreUtilization,
    // Hot Region (assigned by Region)
    IsHotRegion, RegionHotnessPriority, HotRegionVMSeries, LatestHotTimestamp,
    // Regional health
    RegionHealthScore, RegionHealthLevel, RegionHealthProjectedTime
""";
        }

private static Dictionary<string, int> GetColumnMappings(IDataReader reader)
{
    var map = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
    for (int i = 0; i < reader.FieldCount; i++)
        map[reader.GetName(i)] = i;
    return map;
}

    private static ClusterData MapReaderToClusterData(IDataReader reader, Dictionary<string, int> col)
    {
        return new ClusterData
        {
            // Identification & Region
            ClusterId = GetSafeString(reader, col["ClusterId"]),
            Region = GetSafeString(reader, col["Region"]),
            AvailabilityZone = GetSafeString(reader, col["AvailabilityZone"]),
            DataCenter = GetSafeString(reader, col["DataCenter"]),
            PhysicalAZ = GetSafeString(reader, col["PhysicalAZ"]),

            // Age & Decommission
            ClusterAgeYears = GetSafeDouble(reader, col["ClusterAgeYears"]),
            ClusterAgeDays = GetSafeInt(reader, col["ClusterAgeDays"]),
            DecommissionYearsRemaining = GetSafeDouble(reader, col["DecommissionYearsRemaining"]),

            // Intent
            Intent = GetSafeString(reader, col["Intent"]),
            IntentIsSellable = GetSafeBoolean(reader, col["IntentIsSellable"]),

            // Hardware & Infra
            Generation = GetSafeString(reader, col["Generation"]),
            Manufacturer = GetSafeString(reader, col["Manufacturer"]),
            MemCategory = GetSafeString(reader, col["MemCategory"]),
            SKUName = GetSafeString(reader, col["SKUName"]),
            Servers = GetSafeInt(reader, col["Servers"]),
            NumRacks = GetSafeInt(reader, col["NumRacks"]),
            IsUltraSSDEnabled = GetSafeBoolean(reader, col["IsUltraSSDEnabled"]),
            IsSpecialtySKU = GetSafeBoolean(reader, col["IsSpecialtySKU"]),
            CloudType = GetSafeString(reader, col["CloudType"]),
            RegionType = GetSafeString(reader, col["RegionType"]),
            TransitionSKUCategory = GetSafeString(reader, col["TransitionSKUCategory"]),

            PhysicalCoresPerNode = GetSafeInt(reader, col["PhysicalCoresPerNode"]),
            MPCountInCluster = GetSafeInt(reader, col["MPCountInCluster"]),
            RackCountInCluster = GetSafeInt(reader, col["RackCountInCluster"]),
            IsLive = GetSafeBoolean(reader, col["IsLive"]),
            ClusterType = GetSafeString(reader, col["ClusterType"]),
            IsTargetMP = GetSafeBoolean(reader, col["IsTargetMP"]),

            // Utilization
            TotalPhysicalCores = GetSafeDouble(reader, col["TotalPhysicalCores"]),
            UsedCores = GetSafeDouble(reader, col["UsedCores"]),
            UsedCores_SQL = GetSafeDouble(reader, col["UsedCores_SQL"]),
            UsedCores_NonSQL = GetSafeDouble(reader, col["UsedCores_NonSQL"]),
            UsedCores_NonSQL_Spannable = GetSafeDouble(reader, col["UsedCores_NonSQL_Spannable"]),
            UsedCores_NonSQL_NonSpannable = GetSafeDouble(reader, col["UsedCores_NonSQL_NonSpannable"]),
            CoreUtilization = GetSafeDouble(reader, col["CoreUtilization"]),

            VMCount = GetSafeInt(reader, col["VMCount"]),
            VMCount_SQL = GetSafeInt(reader, col["VMCount_SQL"]),
            VMCount_NonSQL = GetSafeInt(reader, col["VMCount_NonSQL"]),
            VMCount_NonSQL_Spannable = GetSafeInt(reader, col["VMCount_NonSQL_Spannable"]),
            VMCount_NonSQL_NonSpannable = GetSafeInt(reader, col["VMCount_NonSQL_NonSpannable"]),
            MaxSupportedVMs = GetSafeInt(reader, col["MaxSupportedVMs"]),
            VMDensity = GetSafeDouble(reader, col["VMDensity"]),

            // Nodes & Risk (TIP_Nodes removed)
            TotalNodes = GetSafeInt(reader, col["TotalNodes"]),
            OutOfServiceNodes = GetSafeInt(reader, col["OutOfServiceNodes"]),
            DNG_Nodes = GetSafeInt(reader, col["DNG_Nodes"]),
            StrandedCores_DNG = GetSafeDouble(reader, col["StrandedCores_DNG"]),
            StrandedCores_TIP = GetSafeDouble(reader, col["StrandedCores_TIP"]),
            OutOfServicesPercentage = GetSafeDouble(reader, col["OutOfServicesPercentage"]),
            NodeCount_IOwnMachine = GetSafeInt(reader, col["NodeCount_IOwnMachine"]),
            NodeCount_32VMs = GetSafeInt(reader, col["NodeCount_32VMs"]),
            StrandedCores_32VMs = GetSafeDouble(reader, col["StrandedCores_32VMs"]),

            // Tenants
            HasPlatformTenant = GetSafeBoolean(reader, col["HasPlatformTenant"]),
            HasWARP = GetSafeBoolean(reader, col["HasWARP"]),
            HasSLB = GetSafeBoolean(reader, col["HasSLB"]),
            HasSQL = GetSafeBoolean(reader, col["HasSQL"]),
            HasUDGreaterThan10 = GetSafeBoolean(reader, col["HasUDGreaterThan10"]),
            HasInstancesGreaterThan10 = GetSafeBoolean(reader, col["HasInstancesGreaterThan10"]),
            TotalInstances = GetSafeInt(reader, col["TotalInstances"]),
            TenantCount = GetSafeInt(reader, col["TenantCount"]),
            TenantWithMaxFD = GetSafeString(reader, col["TenantWithMaxFD"]),

            // Hot regions (no defaulting)
            IsHotRegion = GetSafeBoolean(reader, col["IsHotRegion"]),
            RegionHotnessPriority = GetSafeInt(reader, col["RegionHotnessPriority"]),
            HotRegionVMSeries = GetSafeString(reader, col["HotRegionVMSeries"]),
            LatestHotTimestamp = GetSafeDateTime(reader, col["LatestHotTimestamp"]),

            // Regional health
            RegionHealthScore = GetSafeDouble(reader, col["RegionHealthScore"]),
            RegionHealthLevel = GetSafeString(reader, col["RegionHealthLevel"]),
            RegionHealthProjectedTime = GetSafeDateTime(reader, col["RegionHealthProjectedTime"])
        };
    }
private static ClusterRow ConvertToClusterRow(ClusterData c)
{
    return new ClusterRow
    {
        Cluster = c.ClusterId,
        Region = c.Region,
        AvailabilityZone = c.AvailabilityZone,
        DataCenter = c.DataCenter,
        PhysicalAZ = c.PhysicalAZ,

        ClusterAgeYears = c.ClusterAgeYears,
        ClusterAgeDays = c.ClusterAgeDays,
        DecommissionYearsRemaining = c.DecommissionYearsRemaining,
        Intent = c.Intent,
        IntentIsSellable = c.IntentIsSellable,

        Generation = c.Generation,
        Manufacturer = c.Manufacturer,
        MemCategory = c.MemCategory,
        SKUName = c.SKUName,
        Servers = c.Servers,
        NumRacks = c.NumRacks,
        IsUltraSSDEnabled = c.IsUltraSSDEnabled,
        IsSpecialtySKU = c.IsSpecialtySKU,
        CloudType = c.CloudType,
        RegionType = c.RegionType,
        TransitionSKUCategory = c.TransitionSKUCategory,

        PhysicalCoresPerNode = c.PhysicalCoresPerNode,
        MPCountInCluster = c.MPCountInCluster,
        RackCountInCluster = c.RackCountInCluster,
        IsLive = c.IsLive,
        ClusterType = c.ClusterType,
        IsTargetMP = c.IsTargetMP,

        TotalPhysicalCores = c.TotalPhysicalCores,
        UsedCores = c.UsedCores,
        UsedCores_SQL = c.UsedCores_SQL,
        UsedCores_NonSQL = c.UsedCores_NonSQL,
        UsedCores_NonSQL_Spannable = c.UsedCores_NonSQL_Spannable,
        UsedCores_NonSQL_NonSpannable = c.UsedCores_NonSQL_NonSpannable,
        CoreUtilization = c.CoreUtilization,

        VMCount = c.VMCount,
        VMCount_SQL = c.VMCount_SQL,
        VMCount_NonSQL = c.VMCount_NonSQL,
        VMCount_NonSQL_Spannable = c.VMCount_NonSQL_Spannable,
        VMCount_NonSQL_NonSpannable = c.VMCount_NonSQL_NonSpannable,
        MaxSupportedVMs = c.MaxSupportedVMs,
        VMDensity = c.VMDensity,

        TotalNodes = c.TotalNodes,
        OutOfServiceNodes = c.OutOfServiceNodes,
        DNG_Nodes = c.DNG_Nodes,
        // TIP_Nodes removed
        StrandedCores_DNG = c.StrandedCores_DNG,
        StrandedCores_TIP = c.StrandedCores_TIP,
        OutOfServicesPercentage = c.OutOfServicesPercentage,
        NodeCount_IOwnMachine = c.NodeCount_IOwnMachine,
        NodeCount_32VMs = c.NodeCount_32VMs,
        StrandedCores_32VMs = c.StrandedCores_32VMs,

        HasPlatformTenant = c.HasPlatformTenant, // (kept your property name)
        HasWARP = c.HasWARP,
        HasSLB = c.HasSLB,
        HasSQL = c.HasSQL,
        HasUDGreaterThan10 = c.HasUDGreaterThan10,
        HasInstancesGreaterThan10 = c.HasInstancesGreaterThan10,
        TotalInstances = c.TotalInstances,
        TenantCount = c.TenantCount,
        TenantWithMaxFD = c.TenantWithMaxFD,

        // ACU / Allocation / TiP analytics / Region context REMOVED

        // Hot regions
        IsHotRegion = c.IsHotRegion,
        RegionHotnessPriority = c.RegionHotnessPriority,
        HotRegionVMSeries = c.HotRegionVMSeries,
        LatestHotTimestamp = c.LatestHotTimestamp,

        // Regional health
        RegionHealthScore = c.RegionHealthScore,
        RegionHealthLevel = c.RegionHealthLevel,
        RegionHealthProjectedTime = c.RegionHealthProjectedTime,
    };
}

        private static string? GetSafeString(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            var v = reader.GetValue(idx);
            return v switch
            {
                string s => s,
                DateTime dt => dt.ToString("o"),
                DateTimeOffset dto => dto.ToString("o"),
                _ => v.ToString()
            };
        }

        private static bool? GetSafeBoolean(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            var v = reader.GetValue(idx);
            return v switch
            {
                bool b => b,
                byte by => by != 0,
                short s => s != 0,
                int i => i != 0,
                long l => l != 0,
                double d => Math.Abs(d) > double.Epsilon,
                decimal m => m != 0m,
                string s when bool.TryParse(s, out var b) => b,
                string s when double.TryParse(s, out var d) => Math.Abs(d) > double.Epsilon,
                _ => null
            };
        }

        private static double? GetSafeDouble(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            var v = reader.GetValue(idx);
            return v switch
            {
                double d => d,
                float f => (double)f,
                decimal m => (double)m,
                int i => i,
                long l => l,
                short s => s,
                byte b => b,
                string s when double.TryParse(s, out var d2) => d2,
                _ => null
            };
        }

        private static int? GetSafeInt(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            var v = reader.GetValue(idx);
            return v switch
            {
                int i => i,
                long l => checked((int)l),
                short s => s,
                byte b => b,
                double d => (int)Math.Round(d, MidpointRounding.AwayFromZero),
                decimal m => (int)Math.Round(m, MidpointRounding.AwayFromZero),
                string s when int.TryParse(s, out var i2) => i2,
                string s when double.TryParse(s, out var d2) => (int)Math.Round(d2, MidpointRounding.AwayFromZero),
                _ => (int?)null
            };
        }

        private static long? GetSafeLong(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            var v = reader.GetValue(idx);
            return v switch
            {
                long l => l,
                int i => i,
                short s => s,
                byte b => b,
                double d => (long)Math.Round(d, MidpointRounding.AwayFromZero),
                decimal m => (long)Math.Round(m, MidpointRounding.AwayFromZero),
                string s when long.TryParse(s, out var l2) => l2,
                string s when double.TryParse(s, out var d2) => (long)Math.Round(d2, MidpointRounding.AwayFromZero),
                _ => (long?)null
            };
        }

        private static DateTime? GetSafeDateTime(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            var v = reader.GetValue(idx);
            return v switch
            {
                DateTime dt => DateTime.SpecifyKind(dt, DateTimeKind.Utc),
                DateTimeOffset dto => dto.UtcDateTime,
                string s when DateTime.TryParse(s, out var dt2) => DateTime.SpecifyKind(dt2, DateTimeKind.Utc),
                _ => (DateTime?)null
            };
        }

        private static List<string>? GetSafeStringList(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            try
            {
                var raw = reader.GetValue(idx);
                if (raw is string s)
                {
                    if (s.TrimStart().StartsWith("["))
                        return System.Text.Json.JsonSerializer.Deserialize<List<string>>(s);

                    return s.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(x => x.Trim()).ToList();
                }
                return null;
            }
            catch { return null; }
        }

        private static Dictionary<string, double>? GetSafeDictionary(IDataReader reader, int idx)
        {
            if (idx < 0 || reader.IsDBNull(idx)) return null;
            try
            {
                var json = reader.GetString(idx);
                using var doc = System.Text.Json.JsonDocument.Parse(json);
                if (doc.RootElement.ValueKind != System.Text.Json.JsonValueKind.Object) return null;

                var dict = new Dictionary<string, double>(StringComparer.OrdinalIgnoreCase);
                foreach (var prop in doc.RootElement.EnumerateObject())
                {
                    if (prop.Value.ValueKind == System.Text.Json.JsonValueKind.Number &&
                        prop.Value.TryGetDouble(out var dv))
                    {
                        dict[prop.Name] = dv;
                    }
                    else if (prop.Value.ValueKind == System.Text.Json.JsonValueKind.String &&
                             double.TryParse(prop.Value.GetString(), out var dv2))
                    {
                        dict[prop.Name] = dv2;
                    }
                }
                return dict;
            }
            catch { return null; }
        }
    }

