// DecomAgent.cs
#nullable enable
using System;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.OpenAI;

namespace MyM365AgentDecommision.Bot
{
    /// <summary>
    /// Orchestrates a single Kernel instance with tool/plug-in calls.
    /// Keeps a strict system prompt so the model *uses tools* for data work.
    /// </summary>
    public sealed class DecomAgent
    {
        private readonly Kernel _kernel;
        private readonly IChatCompletionService _chat;
        private readonly ILogger<DecomAgent> _log;

        public DecomAgent(Kernel kernel, ILogger<DecomAgent> log)
        {
            _kernel = kernel ?? throw new ArgumentNullException(nameof(kernel));
            _chat   = _kernel.GetRequiredService<IChatCompletionService>();
            _log    = log ?? throw new ArgumentNullException(nameof(log));
        }

        // Keep this short, specific, and tool-first.
        private static string SystemPrompt =>
@"You are DecommissioningAgent, a precise assistant for ranking and filtering Azure clusters for decommission.

Hard rules (follow exactly):
- ALWAYS call tools (plugins) for any data/scoring/filtering/eligibility/export questions.
- When asked for tables/cards/exports, call the appropriate tool and return the tool output verbatim (do NOT hand-type tables).
- If user asks for JSON only, return raw JSON (no narration).
- If user asks for an Adaptive Card, return only the Adaptive Card JSON (no extra text).
- Support all ClusterRow fields via filtering/sorting; prefer canonical field names. When unsure, discover via ListFields/DescribeSchema.
- Never invent data or fields. If something is unknown, first call schema/list/distinct helpers to discover.
- For weights/rules persistence, pass the provided sessionKey argument to scoring/eligibility calls when relevant.

Available tool intents (not exhaustive):
• Scoring: rank, explain, compare, what-if; weight get/set/reset.
• Filtering: apply FilterCriteria, summary stats, distinct values, schema/field discovery.
• Eligibility: pass/fail evaluation, explanations, summaries, projections (eligible soon), rules get/validate/save/reset.
• Cards: render Top-N, grouped, compare, explain, sensitivity as Adaptive Card v1.5.
• Export: convert tool JSON results into CSV/JSON files and return the file path envelope.";

        public async Task<DecomChatEnvelope> RunAsync(string userInput, string sessionKey, CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(userInput))
            {
                return new DecomChatEnvelope { ContentType = DecomChatContentType.Text, Text = "" };
            }

            var history = new ChatHistory();
            history.AddSystemMessage(SystemPrompt);
            // Give the model a clear, machine-readable session token it can forward into tool calls.
            history.AddSystemMessage($"SessionKey: {sessionKey}");
            history.AddUserMessage(userInput);

            var exec = new OpenAIPromptExecutionSettings
            {
                Temperature = 0,
                MaxTokens = 1800,
                // In current SK, this is a value (not a method). If your package requires,
                // keep it as-is; do NOT call it like a function.
                ToolCallBehavior = ToolCallBehavior.AutoInvokeKernelFunctions
            };

            var msg = await _chat.GetChatMessageContentAsync(history, exec, _kernel, ct);

            var raw = FlattenText(msg).Trim();
            if (string.IsNullOrEmpty(raw))
            {
                _log.LogDebug("Agent returned no text. Items count = {Count}", msg?.Items?.Count ?? 0);
                return new DecomChatEnvelope { ContentType = DecomChatContentType.Text, Text = "" };
            }

            // The model may wrap JSON/Adaptive Cards in code fences — unwrap safely.
            raw = UnwrapCodeFence(raw).Trim();

            _log.LogDebug("Raw agent response (trimmed): {raw}", raw);

            var kind = DetectContentType(raw);
            return kind switch
            {
                DecomChatContentType.AdaptiveCard => new DecomChatEnvelope { ContentType = DecomChatContentType.AdaptiveCard, AdaptiveCardJson = raw },
                DecomChatContentType.Json        => new DecomChatEnvelope { ContentType = DecomChatContentType.Json, Json = raw },
                _                                 => new DecomChatEnvelope { ContentType = DecomChatContentType.Text, Text = raw }
            };
        }

        // -------- Helpers ------------------------------------------------------

        private static string FlattenText(ChatMessageContent? msg)
        {
            if (msg is null) return string.Empty;

            // If Content is already populated, prefer it.
            var s = msg.Content;
            if (!string.IsNullOrWhiteSpace(s)) return s!;

            // Otherwise, concatenate any TextContent items.
            var sb = new StringBuilder();
            foreach (var item in msg.Items)
            {
                if (item is TextContent tc && !string.IsNullOrEmpty(tc.Text))
                    sb.Append(tc.Text);
            }
            return sb.ToString();
        }

        private static string UnwrapCodeFence(string s)
        {
            var text = s.Trim();

            // ```json\n ... \n```  OR  ```adaptivecard\n ... \n```
            if (text.StartsWith("```", StringComparison.Ordinal))
            {
                // Strip leading ```lang?
                var firstNewline = text.IndexOf('\n');
                if (firstNewline > 0)
                {
                    text = text[(firstNewline + 1)..];
                }
                // Strip trailing ```
                var tail = text.LastIndexOf("```", StringComparison.Ordinal);
                if (tail >= 0)
                {
                    text = text[..tail];
                }
            }
            return text.Trim();
        }

        private static DecomChatContentType DetectContentType(string s)
        {
            var ss = s.Trim();
            if (ss.Length == 0) return DecomChatContentType.Text;

            bool looksJson = (ss.StartsWith("{") && ss.EndsWith("}")) || (ss.StartsWith("[") && ss.EndsWith("]"));

            // Strong Adaptive Card signals
            bool looksCard =
                (looksJson &&
                 (ss.IndexOf("\"type\":\"AdaptiveCard\"", StringComparison.OrdinalIgnoreCase) >= 0 ||
                  ss.IndexOf("\"type\": \"AdaptiveCard\"", StringComparison.OrdinalIgnoreCase) >= 0 ||
                  ss.IndexOf("\"$schema\"", StringComparison.OrdinalIgnoreCase) >= 0) &&
                 ss.IndexOf("adaptivecards.io", StringComparison.OrdinalIgnoreCase) >= 0);

            if (looksCard) return DecomChatContentType.AdaptiveCard;
            if (looksJson) return DecomChatContentType.Json;
            return DecomChatContentType.Text;
        }
    }

    /// <summary>Envelope returned to the bot for rendering.</summary>
    public sealed class DecomChatEnvelope
    {
        public DecomChatContentType ContentType { get; set; } = DecomChatContentType.Text;
        public string? Text { get; set; }
        public string? AdaptiveCardJson { get; set; } // v1.5 as string
        public string? Json { get; set; }             // raw JSON if requested
    }

    public enum DecomChatContentType { Text, AdaptiveCard, Json }
}
