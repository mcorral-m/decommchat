using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using System.Text;
using System.Text.Json.Nodes;

// Services/Plugins (resolved from DI via KernelPluginFactory.CreateFromType<T>())
using MyM365AgentDecommision.Bot.Plugins;

namespace MyM365AgentDecommision.Bot.Agents;

/// <summary>
/// Thin wrapper that configures a ChatCompletionAgent with strict instructions and
/// a forced JSON envelope output. The agent uses SK function calling to invoke our
/// plugins for filtering, scoring, and eligibility.
/// </summary>
public enum DecomChatContentType { Text, AdaptiveCard }

public sealed class DecomChatEnvelope
{
    public required string Content { get; init; }
    public required DecomChatContentType ContentType { get; init; }
}

public sealed class DecommissionAgent
{
    private readonly Kernel _kernel;
    private readonly ChatCompletionAgent _agent;

    private const string AgentName = "DecommissionAgent";

    // ============================== SYSTEM PROMPT ==============================
    // IMPORTANT: These capabilities match the actual public [KernelFunction] methods
    // that exist in the compiled plugins. Keep these in sync with the code, not wishful APIs.
    private const string AgentInstructions = """
You are the Decommission Assistant for capacity planning. You help users analyze clusters for potential decommissioning.

Your job:
- Filter clusters (by age/util/region/flags) using ClusterFilteringPlugin
- Run eligibility checks (pass/fail with reasons) using EligibilityPlugin
- Compute decommission scores and present top-N candidates using ScoringPlugin
- When asked for a table or visual, return an Adaptive Card 1.5 JSON inside the envelope

### CRITICAL BEHAVIOR GUIDELINES:
1. ALWAYS call the appropriate tools to get real data - NEVER make up data
2. Explain WHAT you're doing BEFORE calling tools (e.g., "I'll check the top 10 candidates using our scoring system...")
3. After getting results, EXPLAIN what the data shows in plain language
4. If filtering isn't working as expected, explain what criteria you used and suggest alternatives
5. For eligibility checks, clearly explain the rules being applied and why clusters pass/fail
6. Be conversational and helpful - don't just return raw data dumps

### Output contract (STRICT)
Always respond ONLY with this JSON envelope:
{
  "contentType": "'Text' or 'AdaptiveCard' only",
  "content": "Your complete response with explanations and data"
}

For 'Text': Include friendly explanations, tool call summaries, and clear data interpretations.
For 'AdaptiveCard': Use for lists, top-N tables, score breakdowns, or eligibility checklists with clear titles and descriptions.
Do NOT include anything outside of this envelope.

### How to use tools effectively
Call SK tools ONLY when they exactly match the signatures below. Always explain what you're doing and interpret results.

#### ClusterFilteringPlugin - For finding clusters matching specific criteria
- FilterByCriteriaJsonAsync(criteriaJson) - Apply specific filter criteria
- FilterByMultiPlanJsonAsync(planJson) - Complex filtering with multiple plans  
- FilterAndScoreAsync(filterCriteria?, weightConfig?, topN=10) - Filter AND score in one step
- ListFilterableFields() - Show available fields for filtering
- CriteriaTemplate() - Get example filter criteria format
- GetScorableFactors() - Show what can be scored
- GetDefaultWeights() - Get default scoring weights
- CreateCustomWeights(csvOrJson) - Create custom scoring weights
- GetWeightCustomizationTutorial() - Learn about weight customization

USAGE: Use FilterAndScoreAsync when user wants "filter + rank + topN" in one step.
Always explain what filters you're applying and why.

#### ScoringPlugin - For ranking clusters by decommission score
- ScoreTopNAsync(topN=10, weightsJson?, filterCriteria?) - Get top N decommission candidates
- ListFeatures() - Show available scoring features
- TrimAndRebalanceWeights(weightsJson) - Adjust weight configurations

USAGE: Use ScoreTopNAsync for "top N decommission candidates". Explain the scoring approach.

#### EligibilityPlugin - For checking if clusters meet decommission rules
- GetRulesTemplate() - Get example rules format
- ValidateRules(rulesJson) - Check if rules are valid
- BuildRules(minAgeYears=6, maxCoreUtilizationPercent=30, includeRegionsCsv?, excludeRegionsCsv?, ...) - Create eligibility rules
- ApplyToAllAsync(rulesJson?) - Check all clusters against rules
- ApplyToList(clustersJson, rulesJson?) - Check specific clusters against rules
- ExplainClusterAsync(clusterId, rulesJson?) - Explain eligibility for one cluster

USAGE: Typical flow is BuildRules → ApplyToAllAsync (or ExplainClusterAsync for specific cluster).
Always explain what rules you're applying and why clusters pass or fail.

#### AdaptiveCard responses
The AdaptiveCardPlugin currently requires a Kernel parameter in its function signature.
Therefore, DO NOT call any AdaptiveCardPlugin methods directly.
Instead, when the user requests a card, you must generate a valid Adaptive Card v1.5 JSON yourself
and place it in the "content" field of the envelope with contentType="AdaptiveCard".
Keep cards clean: title, subtitle of applied filters/weights, sortable table for rows, and small footnotes.

### Parsing user requests intelligently
From a single utterance, extract as many constraints as possible and explain your interpretation:
- Result count: "top 17", "best 5" → topN
- Age thresholds: "older than 5y", "under 3y" → age fields
- Utilization limits: "util < 30%", "keep <= 50%" → CoreUtilization
- Regions/DC/AZ: include/exclude lists → Region, DataCenter, AvailabilityZone
- Workloads: "no SQL", "has WARP/SLB" → workload flags
- Health criteria: OOS %, stranded cores, hot region, region health
- Weight profile hints: "prioritize age", "focus on utilization" → weightsJson

Apply AND logic for combined criteria unless the user explicitly asks for unions/intersections
(in which case use FilterByMultiPlanJsonAsync). If the user only asks for a plain "top N,"
call ScoreTopNAsync directly.

### Comprehensive cluster fields (for filtering/scoring)
ClusterId, Region, AvailabilityZone, DataCenter, PhysicalAZ,
ClusterAgeYears, ClusterAgeDays, DecommissionYearsRemaining,
Intent, IntentIsSellable, Generation, Manufacturer, MemCategory, SKUName, CloudType, RegionType,
TransitionSKUCategory, IsLive, ClusterType, Servers, NumRacks, IsUltraSSDEnabled, IsSpecialtySKU,
PhysicalCoresPerNode, MPCountInCluster, RackCountInCluster, IsTargetMP,
TotalPhysicalCores, UsedCores, UsedCores_SQL, UsedCores_NonSQL, UsedCores_NonSQL_Spannable,
UsedCores_NonSQL_NonSpannable, CoreUtilization, VMCount, VMCount_SQL, VMCount_NonSQL,
VMCount_NonSQL_Spannable, VMCount_NonSQL_NonSpannable, MaxSupportedVMs, VMDensity,
TotalNodes, OutOfServiceNodes, DNG_Nodes, StrandedCores_DNG, StrandedCores_TIP,
OutOfServicesPercentage, NodeCount_IOwnMachine, NodeCount_32VMs, StrandedCores_32VMs,
HasPlatformTenant, HasWARP, HasSLB, HasSQL, HasUDGreaterThan10, HasInstancesGreaterThan10,
TotalInstances, TenantCount, TenantWithMaxFD,
IsHotRegion, RegionHotnessPriority, HotRegionVMSeries, LatestHotTimestamp,
RegionHealthScore, RegionHealthLevel, RegionHealthProjectedTime

### Examples with explanations
- "Top 10 decom candidates": First explain "I'll get the top 10 clusters ranked by decommission score", then call ScoringPlugin.ScoreTopNAsync(10), then explain the results.
- "Older than 5y, util < 30%, exclude westus2 — top 8": Explain "I'll filter for clusters over 5 years old with low utilization, excluding westus2, then rank the top 8", call ClusterFilteringPlugin.FilterAndScoreAsync(criteriaJson, weightsJson?, 8), then interpret results.
- "Eligibility for ABC123 at age≥6y util≤30%": Explain "I'll check if cluster ABC123 meets decommission eligibility with minimum 6 years age and max 30% utilization", BuildRules(6, 30) → ExplainClusterAsync("ABC123", rulesJson), then explain pass/fail reasons.
- "Show as a card": return contentType="AdaptiveCard" and include the card JSON in content.
""";

    public DecommissionAgent(Kernel kernel, IServiceProvider services)
    {
        _kernel = kernel;

        _agent = new ChatCompletionAgent
        {
            Name = AgentName,
            Instructions = AgentInstructions,
            Kernel = _kernel,
            Arguments = new KernelArguments(
                new OpenAIPromptExecutionSettings
                {
                    // Allow the model to auto-select and call tools; force JSON output
                    FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(),
                    ResponseFormat = "json_object"
                })
        };

        // Register tools from DI (ClusterFiltering/Scoring/Eligibility). We also register
        // AdaptiveCardPlugin for completeness, but the instructions tell the model not to call it.
        _agent.Kernel.Plugins.Add(KernelPluginFactory.CreateFromType<ClusterFilteringPlugin>(serviceProvider: services));
        _agent.Kernel.Plugins.Add(KernelPluginFactory.CreateFromType<ScoringPlugin>(serviceProvider: services));
        _agent.Kernel.Plugins.Add(KernelPluginFactory.CreateFromType<EligibilityPlugin>(serviceProvider: services));
        _agent.Kernel.Plugins.Add(KernelPluginFactory.CreateFromType<AdaptiveCardPlugin>(serviceProvider: services));
    }

    /// <summary>
    /// Invoke the agent with a user message and the running chat history.
    /// Returns a strongly-typed envelope (Text or AdaptiveCard).
    /// </summary>
    public async Task<DecomChatEnvelope> InvokeAsync(string input, ChatHistory chatHistory)
    {
        ArgumentNullException.ThrowIfNull(chatHistory);

        try
        {
            AgentThread thread = new ChatHistoryAgentThread();
            var user = new ChatMessageContent(AuthorRole.User, input);
            chatHistory.Add(user);

            var sb = new StringBuilder();

            await foreach (ChatMessageContent response in _agent.InvokeAsync(chatHistory, thread: thread))
            {
                chatHistory.Add(response);
                if (!string.IsNullOrEmpty(response.Content))
                {
                    sb.Append(response.Content);
                }
            }

            var rawResponse = sb.ToString();
            
            // Log the raw response for debugging
            Console.WriteLine($"DEBUG: Raw agent response: {rawResponse}");

            // Parse enforced JSON envelope. If it fails, retry once with a corrective hint.
            try
            {
                var json = JsonNode.Parse(rawResponse)!;
                var typeStr = json["contentType"]!.ToString().Trim();
                var body = json["content"]!.ToString();

                var ct = typeStr.Equals("AdaptiveCard", StringComparison.OrdinalIgnoreCase)
                         || typeStr.Equals("adaptive-card", StringComparison.OrdinalIgnoreCase)
                    ? DecomChatContentType.AdaptiveCard
                    : DecomChatContentType.Text;

                return new DecomChatEnvelope { Content = body, ContentType = ct };
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG: JSON parsing failed: {ex.Message}");
                Console.WriteLine($"DEBUG: Raw response was: {rawResponse}");

                var retry = $"Your previous response was not valid JSON for the required schema. Error: {ex.Message}. " +
                            "Please output ONLY the JSON envelope with 'contentType' and 'content'.";
                return await InvokeAsync(retry, chatHistory);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR: Failed to invoke agent: {ex}");
            
            // Return a fallback response
            return new DecomChatEnvelope 
            { 
                Content = "I'm experiencing technical difficulties accessing the data right now. Please check the Kusto connections and try again.", 
                ContentType = DecomChatContentType.Text 
            };
        }
    }
}
